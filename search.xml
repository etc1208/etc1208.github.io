<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[withCredentials与CORS的爱恨情仇]]></title>
    <url>%2F2019%2F03%2F28%2FwithCredentials%E4%B8%8ECORS%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87%2F</url>
    <content type="text"><![CDATA[在日常开发中，跨域是我们老生常谈的话题。为什么存在跨域呢？因为浏览器有同源策略，而我们实际的开发过程中时长存在哪种场景呢：从a域向b域发请求，浏览器就开始搞事情了。总之一句话，一切为了安全。这里不再去赘述跨域的一个个解决办法，比如我们常说的JSONP、domian、代理、postMessage等方式，此文仅简单记录CORS的一些琐碎。 cookie 一般用于身份验证 服务端通过在响应头加入Set-Cookie字段向浏览器写cookie 浏览器向服务端发送请求时可以将cookie附加在HTTP请求的头字段Cookie中 服务端可以设置httpOnly，使得前端无法操作cookie 服务端可以设置secure，保证在https的加密通信中传输以防截获 CORS 跨域资源共享,它允许浏览器向跨源服务器发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制 需要浏览器和服务器同时支持 JSONP只支持GET请求，CORS支持所有类型的HTTP请求 引用阮一峰老师的一段话：“整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。” 两种请求 简单请求 非简单请求 简单请求 浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。 Origin 字段表示请求源，服务器根据这个值决定是否同意这次请求。 Origin 不在许可范围内 响应头信息没有包含Access-Control-Allow-Origin字段，被XMLHttpRequest的onerror回调函数捕获。 注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 Origin 在许可范围内 服务器返回的响应，会多出几个头信息字段: Access-Control-Allow-Origin: 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求 Access-Control-Allow-Credentials: 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie Access-Control-Expose-Headers 非简单请求 对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json 正式通信之前，增加一次预检请求（preflight）。 请求方法是OPTIONS 头信息里面，关键字段是Origin，表示请求来自哪个源 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 通过了预检请求后，就会发出正常的CORS请求，会有一个Origin头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin 头信息字段。 withCredentials CORS请求默认不发送Cookie和HTTP认证信息。 如果要把Cookie发到服务器,需要client + server 共同努力： 服务端：设置Access-Control-Allow-Credentials: true 客户端：设置withCredentials属性 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 永远不会影响到同源请求 如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号!!!!!必须指定明确的、与请求网页一致的域名！！！！！具体参见Reason: Credential is not supported if the CORS header ‘Access-Control-Allow-Origin’ is ‘*’]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome的断点调试]]></title>
    <url>%2F2019%2F03%2F22%2FChrome%E7%9A%84%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[前端开发离不开浏览器环境的debug，chrome为我们提供了断点调试的诸多便利，利用断点调试我们可以触达代码逻辑细微之处、DOM元素变化的瞬间、XHR请求的发生、事件监听的触发等等；有助于我们对bug的追踪排查。这篇笔记记录chrome断点调试js代码的种种功能，在开发过程中提高我们的debug效率。 各类断点使用时间概览 断点类型 使用情况 代码行 在确切的代码区域中。 条件代码行 在确切的代码区域中，且仅当其他一些条件成立时。 DOM 在更改或移除特定 DOM 节点或其子级的代码中。 XHR 当 XHR 网址包含字符串模式时。 事件侦听器 在触发 click 等事件后运行的代码中。 异常 在引发已捕获或未捕获异常的代码行中。 函数 任何时候调用特定函数时。 代码行断点在 DevTools 中设置代码行断点在知道需要调查的确切代码区域时，可以使用代码行断点。 DevTools 始终会在执行此代码行之前暂停。 在 DevTools 中设置代码行断点： 点击 Sources 标签。 打开包含您想要中断的代码行的文件。 转至代码行。 代码行的左侧是行号列。 点击行号列。 行号列顶部将显示一个蓝色图标。 代码中的代码行断点在代码中调用 debugger 可在该行暂停。 此操作相当于使用代码行断点，只是此断点是在代码中设置，而不是在 DevTools 界面中设置。 1234console.log(&apos;a&apos;);console.log(&apos;b&apos;);debugger;console.log(&apos;c&apos;); 条件代码行断点如果知道需要调查的确切代码区域，但只想在其他一些条件成立时进行暂停，则可使用条件代码行断点。 若要设置条件代码行断点： 点击 Sources 标签。 打开包含您想要中断的代码行的文件。 转至代码行。 代码行的左侧是行号列。 右键点击行号列。 选择 Add conditional breakpoint。 代码行下方将显示一个对话框。 在对话框中输入条件。 按 Enter 键激活断点。 行号列顶部将显示一个橙色图标。 管理代码行断点使用 Breakpoints 窗格可以从单个位置停用或移除代码行断点。 勾选条目旁的复选框可以停用相应的断点。 右键点击条目可以移除相应的断点。 右键点击 Breakpoints 窗格中的任意位置可以取消激活所有断点、停用所有断点，或移除所有断点。 停用所有断点相当于取消选中每个断点。 取消激活所有断点可让 DevTools 忽略所有代码行断点，但同时会继续保持其启用状态，以使这些断点的状态与取消激活之前相同。 DOM 更改断点如果想要暂停更改 DOM 节点或其子级的代码，可以使用 DOM 更改断点。 若要设置 DOM 更改断点： 点击 Elements 标签。 转至要设置断点的元素。 右键点击此元素。 将鼠标指针悬停在 Break on 上，然后选择 Subtree modifications、Attribute modifications 或 Node removal。 XHR/Fetch 断点如果想在 XHR 的请求网址包含指定字符串时中断，可以使用 XHR 断点。 DevTools 会在 XHR 调用 send() 的代码行暂停。 注：此功能还可用于 Fetch 请求。 例如，在您发现您的页面请求的是错误网址，并且您想要快速找到导致错误请求的 AJAX 或 Fetch 源代码时，这类断点很有用。 若要设置 XHR 断点： 点击 Sources 标签。 展开 XHR Breakpoints 窗格。 点击 Add breakpoint。 输入要对其设置断点的字符串。 DevTools 会在 XHR 的请求网址的任意位置显示此字符串时暂停。 按 Enter 键以确认。 事件侦听器断点如果想要暂停触发事件后运行的事件侦听器代码，可以使用事件侦听器断点。 您可以选择 click 等特定事件或所有鼠标事件等事件类别。 点击 Sources 标签。 展开 Event Listener Breakpoints 窗格。 DevTools 会显示 Animation 等事件类别列表。 勾选这些类别之一以在触发该类别的任何事件时暂停，或者展开类别并勾选特定事件。 异常断点如果想要在引发已捕获或未捕获异常的代码行暂停，可以使用异常断点。 点击 Sources 标签。 点击 Pause on exceptions。 启用后，此按钮变为蓝色。 （可选）如果除未捕获异常以外，还想在引发已捕获异常时暂停，则勾选 Pause On Caught Exceptions 复选框。 函数断点函数断点 如果想要在调用特定函数时暂停，可以调用 debug(functionName)，其中 functionName 是要调试的函数。 您可以将 debug() 插入您的代码（如 console.log() 语句），也可以从 DevTools 控制台中进行调用。 debug() 相当于在第一行函数中设置代码行断点。 123456function sum(a, b) &#123; let result = a + b; // DevTools pauses on this line. return result;&#125;debug(sum); // Pass the function object, not a string.sum();]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年我们一起追过的mpvue]]></title>
    <url>%2F2019%2F01%2F10%2Fmpvue%E9%87%87%E5%9D%91%2F</url>
    <content type="text"><![CDATA[这里我们并不会深入讲述小程序开发;这次分享刚刚走到小程序开发的大门口，门口有你、有我、有坑;鲁迅说过：世上本没有坑，踩的人多了就有了坑; what is mpvue ?mpvue 是一个使用 Vue.js 开发小程序的前端框架。框架基于 Vue.js 核心，mpvue 修改了 Vue.js 的 runtime 和 compiler 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验。 全局安装 vue-cli1$ npm install --global vue-cli vue cli 之于 vue creact-react-app 之于 react 题外话：vue-cli &amp; @vue/cli * 两者其实是一个东西 从3.0开始：从 vue-cli 更名为 @vue/cli 如果你使用vue cli 3，官方要求：“ Vue CLI requires Node.js version 8.9 or above (8.11.0+ recommended) ” 12345// cli 2npm install -g vue-cli // cli 3npm install -g @vue/cli 两个版本的详细区别这里不做重点，我们只说创建项目 12345// cli 2vue init &lt;template-name&gt; &lt;project-name&gt; // cli 3vue create &lt;project-name&gt; 因为mpvue官方提供的是基于模板(template)初始化项目，而vue cli3不再直接支持；同时官方也为我们提供了在3的基础上使用template的方式：安装一个全局桥 初始化mpvue 创建一个基于 mpvue-quickstart 模板的新项目 12// 新手一路回车选择默认就可以了$ vue init mpvue/mpvue-quickstart my-project 安装依赖 123$ cd my-project$ npm install$ npm run dev 如果你和我一样使用nvm管理本地node版本，必须手动nvm use xx切换一次 *（e.g.哪怕当前就是在node 8版本下也要手动执行一次nvm use 8），否则初始化mpvue项目时就会失败：报错 vue-cli · [.eslintrc.js] Missing helper: “if_eq” 生成目录结构 导入微信开发者工具 如果我们按照官方指引一步步导入，是不能正常跑起来项目的，会报错：未找到入口 app.json 文件，或者文件读取失败，请检查后重新编译。 原因在：project.config.json * 这个文件是用来存储项目配置的，每次微信开发者工具导入mpvue项目后会依据这个配置文件去加载项目； 那么我们看这个文件里有这样一条配置项：”miniprogramRoot”: “dist”, 它就是告诉微信开发者工具：这个目录下有我打包好的微信小程序，你快去加载 补充：app.json是什么 * app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等； 它是必须的！（而我们去看打包好的dist目录下哪里有app.json？？只有一个wx目录，自然会报错找不到） 解决办法：更改project.config.json中的miniprogramRoot项为”dist/wx”，这样微信开发者工具就会自动去这个目录下加载小程序所需资源；亦或者直接导入dist/wx目录自然也是可以的 补充：只有直接导入dist/wx目录才能使用预览功能，原因未知 页面配置 app.json中的pages字段设定了当前小程序包含的页面（相当于路由），其中以^开头的会作为小程序首页对待，否则默认出现在pages数组的第一项为首页； 我们看到对应pages目录下分布着一个个页面，每个里面都有一个main.js，并且内容极其相似甚至完全一样； 另外，官方Q&amp;A中关于页面配置提到一点： mpvue本身页面配置的缺陷： • mpvue新增页面或者模块的时候必须重新npm run dev才可以进行更新，不支持热更新;（官方告诉我们要忍） • mpvue所有页面模块除了.vue文件外，都需要写一个很类似的main.js，重复工作; 推荐一个第三方的插件：mpvue-entry 该插件使得我们新建页面时只需要一个.vue文件，并且将页面路由通过一个js文件统一配置 优点：集中式页面配置，自动生成各页面的入口文件，优化目录结构 mpvue-entry根据官方的readme，我们一步步来： 安装：npm i mpvue-entry -D 使用 修改webpack.base.conf.js 新增pages.js配置文件 调整原来的pages目录结构（去掉冗余的main.js） 对应修改app.json的pages配置！！！ 在官方readme里我们注意到： v1.5.0 版本开始支持 mpvue-loader@^1.1.0 版本，新版 src 目录下需存在 app.json 文件，预计 v2.0 版本不再兼容旧版 mpvue-loader 编译通过，导入微信开发者工具,报错了： 未找到入口 app.json 文件，或者文件读取失败，请检查后重新编译。* 仔细查看：dist/wx中的app.json怎么搬家跑到上层去了？！ 原因有二： 官方指引中让务必删去的配置部分导致本该复制到dist/wx目录下的app.json没有被复制； mpvue-entry帮我们在dist目录下生成了一个app.json 怎么办呢？ * 办法一（不能完美解决）：先把刚刚“务必删去”的配置部分加回来；结果：存在两个app.json,而且还稍有不同① mpvue-entry帮我们在dist目录下生成的app.json多了个subPackages项:分包；稍后会讲到。② mpvue-loader帮我们在dist/wx下生成了一个app.json,就是src/app.json的复制品；③ pages.js中关于单页面的配置(标题等)不生效 对于单个页面的配置：官方提供的方法是: 通过在每个page的main.js中export独立的配置： 12345export default &#123; config: &#123; navigationBarTitleText: &apos;第二页标题&apos; &#125;&#125; （main.js都给干掉了，pass！并且我测试了一下在不接入mpvue-entry的情况下这个方法也是无效的，需要在每个page目录下新建一个main.json文件进行配置） 但还是有办法的：通过调用 wx API 动态设置； 12345onLoad() &#123; wx.setNavigationBarTitle(&#123;‘title’: ‘xxxx’ &#125;)&#125; 真正的解决办法：mpvue_entry应该支持构建路径可配置啥的，于是往下翻文档，果不其然： 一切似乎在朝着更好的方向发展：只有一个app.json了 &amp; 单页面的配置生效了 但我们仔细看在dist/wx下构建出的app.json是和src/app.json一模一样的（它实际是mpvue-loader复制过去的，覆盖了mpvue-entry构建出来的app.json） ！！这就解释了为何mpvue-entry要求务必删去webpack.base.conf.js中复制json的配置 分包刚刚我们跳过了一个概念：分包。它的功效类比于webpack打包出来的多个chunk 每个使用分包小程序必定含有一个主包。主包就是包含启动页面的包。 在小程序启动时，默认会下载主包进入首页，当用户进入分包内某个页面时，客户端才会把对应分包下载下来，下载完成后再进行展示。 对小程序进行分包，可以优化小程序首屏时间 接入vuex 1.安装依赖：yarn add vuex 2.state &amp; getters &amp; mutations &amp;actions等基础配置 3.入口处添加store 补充：Logger &amp; 严格模式 1.Logger plugin 因为在微信开发者工具中没有 vue-devtools，最好在开发模式下配置vuex的logger插件，方便观察状态变化； 2.严格模式 在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。 不要在发布环境下启用严格模式！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。 如果你并未接入mpvue-entry，最初的项目中接入vuex后，是会遇到问题的： 入口处无法通过new Vue({store, …App})这种形式传入store 必须在每个page下的main.js中注入才能生效;(也有绕过去的办法，就是在入口处通过Vue.prototype.$store = store绑定store，这样在每个子page中就可以访问到store了 网络请求 说明：微信小程序的 js运行环境和浏览器不同，页面的脚本逻辑是在JsCore中运行，JsCore是一个没有窗口对象的环境，访问不了window，也没有XmlhttpRequest等对象；所以像jquery 、zepto、axios这些在小程序中都不能直接使用 方案一： 封装wx.request（不再赘述，参考微信官方文档） 方案二：Flyio 一个支持所有JS运行环境的基于Promise的、支持请求转发、强大的http请求库。可以在多端最大限度的实现代码复用。 目前支持的平台包括：Node.js 、微信小程序 、Weex 、React Native 、Quick App 和浏览器。 番外不支持部分复杂的 JavaScript 渲染表达式官方举例是这样的： 123456789// 这种就不支持，建议写 computed&lt;p&gt;&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;/p&gt;// 但写在 @event 里面的表达式是都支持的，因为这部分的计算放在了 vdom 里面&lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt; &lt;div @click=&quot;clickHandle(item, index, $event)&quot;&gt;&#123;&#123; item.value &#125;&#125;&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 12比如&lt;h4&gt;当前值：&#123;&#123;number&#125;&#125;&lt;/h4&gt;是可以的；&lt;h4&gt;&#123;&#123;`当前值：$&#123;number&#125;`&#125;&#125;&lt;/h4&gt;就会报错: number is undefined 页面关闭后，重进数据状态并未初始化这个是mpvue已知的问题，开发者正在解决（但其实已经很久了仍未解决）解决办法就是利用一些生命周期钩子重新初始化一次数据，如： 1234onHide() &#123; // 退出页面时候 this.reset()&#125; 生命周期钩子 created：小程序加载后，所有页面的created钩子都会被调用，而且只调用这一次；可以用小程序的onLoad钩子代替（在每个页面进入后执行一次） mounted：page A -&gt; page B -&gt; page A，此时页面A的mounted钩子不会被触发，因为小程序的历史页面不会被销毁；如果有需要每次页面展示都要调用的逻辑，可以使用小程序的onShow代替 小心后台页面的js小程序中可能有n个页面，所有的这些页面，虽然都拥有自己的webview， 但是却共享同一个js运行环境。当你从A跳到B，A的定时器等js操作仍在进行，并且不会被销毁，并且会抢占B页面的资源。 在h5的环境中，当我们跳转到其他页面，老页面的js环境会被自动销毁，定时器什么都被销毁掉了，因此我们不需要关心老页面中还有哪些js代码可能还会执行。但是在小程序中，我们必须手动的“清理”掉这样的代码。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Vue</tag>
        <tag>小程序</tag>
        <tag>mpvue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next.js初探]]></title>
    <url>%2F2018%2F12%2F30%2Fnext-js%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[next.js 是一个轻量级的react同构框架，使用它可以快速的开发出基于服务端渲染的react应用。它在支持ssr的同时支持快速导出静态站点，相比与常规的SPA页面，利用ssr我们能够得到更好的SEO和首屏响应时间等。这次恰好赶上从零开始的海外wap主站项目，借此机会一探next.js的究竟。之前组内使用的前后端同构脚手架是react-starter-kit,它很不错但总感觉有点重；一直想找机会试一试React官方推荐的Next,so~~机会来啦！ 是什么 a lightweight framework for static and server‑rendered applications built with React. includes styling and routing solutions out of the box 特点 轻量 默认支持ssr 自动 code splitting 简洁的路由 (page based) HMR &amp; 明确的错误提示 自由组合Express等Node.js HTTP server Babel 、Webpack等零配置&amp;可扩展 开始一个next项目12345mkdir hello-nextcd hello-nextnpm init -ynpm install --save react react-dom nextmkdir pages package.json: 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;next&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start&quot;&#125; 路由 pages即路由:根据pages目录默认生成路由配置 路由： / : pages/index.js /about : pages/about.js /a : pages/a/index.js /b/c : pages/b/c/index.js 问题1：a/index.js 与a.js 谁的优先级高 问题2：动态路由（稍后解决）client side Routingwith 1234567891011import Link from &apos;next/link&apos;export default () =&gt; ( &lt;div&gt; Click&#123;&apos; &apos;&#125; &lt;Link href=“/a/b“ as=“/ab”&gt; &lt;a&gt;here&lt;/a&gt; &lt;/Link&gt;&#123;&apos; &apos;&#125; to read more &lt;/div&gt;) 常用属性： prefetch URL object Replace Imperatively123456789import Router from &apos;next/router&apos;const clickHandler = () =&gt; &#123; Router.push(&apos;/about&apos;)&#125;export default () =&gt; ( &lt;span onClick=&#123;() =&gt; clickHandler()&#125;&gt; Click here&lt;/span&gt; ) Router包含以下属性&amp;API : route/pathname/query/asPath/push/replace等 Router内包含事件 : routeChangeStart/routeChangeComplete/routeChangeError/beforeHistoryChange/hashChangeStart/hashChangeComplete 12e.g.Router.events.on(&apos;routeChangeStart&apos;, handleRouteChange) Higher Order Component123456789import &#123; withRouter &#125; from &apos;next/router&apos;const ActiveLink = (&#123; children, router, href &#125;) =&gt; &#123; return ( &lt;a href=&#123;href&#125;&gt;&#123;children&#125;&lt;/a&gt; )&#125;export default withRouter(ActiveLink) 组件被注入router props，其包含属性同 next/router. Custom server and routing client side：利用asPath属性 server side：自定义server.js package.json：修改scripts asPath1234567&lt;Link href=&quot;/a/b&quot; as=&quot;/ab&quot;&gt; &lt;a&gt;here&lt;/a&gt;&lt;/Link&gt;or:Router.push(&apos;/a/b&apos;, &apos;/ab&apos;) Next称之为：Clean URLs with Route Masking但这就存在个问题，这样可以做到client 端路由跳转当手动刷新如/course/detail/2这种路由，server端认识吗？ server.js1234567891011121314151617181920212223242526272829303132const express = require(&apos;express&apos;)const next = require(&apos;next&apos;)const port = parseInt(process.env.PORT, 10) || 3000const dev = process.env.NODE_ENV !== &apos;production&apos;const app = next(&#123; dev &#125;)const handle = app.getRequestHandler()app.prepare() .then(() =&gt; &#123; const server = express() // a页 server.get(&apos;/a&apos;, (req, res) =&gt; renderAndCache(req, res, &apos;/a&apos;, req.query)) // b页 server.get(&apos;/b/:id?&apos;, (req, res) =&gt; renderAndCache(req, res, &apos;/b&apos;, &#123; ...req.query, ...req.params &#125;)) // c页 server.get(&apos;/c&apos;, (req, res) =&gt; app.render(req, res, &apos;/c&apos;, &#123; ...req.query, ...req.params &#125;)) server.get(&apos;*&apos;, (req, res) =&gt; handle(req, res)) server.listen(port, (err) =&gt; &#123; if (err) throw err console.log(`&gt; Ready on http://localhost:$&#123;port&#125;`) &#125;) &#125;) .catch((ex) =&gt; &#123; console.error(ex.stack) process.exit(1) &#125;) package.json12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;node server.js&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;NODE_ENV=production node server.js&quot;&#125; styled-jsx1234567891011121314151617181920212223242526function HelloWorld() &#123; return ( &lt;div&gt; Hello world &lt;p&gt;scoped!&lt;/p&gt; &lt;style jsx&gt;&#123;` p &#123; color: blue; &#125; div &#123; background: red; &#125; @media (max-width: 600px) &#123; div &#123; background: blue; &#125; &#125; `&#125;&lt;/style&gt; &lt;style global jsx&gt;&#123;` body &#123; background: black; &#125; `&#125;&lt;/style&gt; &lt;/div&gt; )&#125; 其他css解决方案： @zeit/next-css @zeit/next-sass @zeit/next-less @zeit/next-stylus Fetching data &amp; component lifecyclegetInitialProps1234567891011121314class HelloUA extends React.Component &#123; static async getInitialProps(&#123; req &#125;) &#123; const userAgent = req ? req.headers[&apos;user-agent&apos;] : navigator.userAgent return &#123; userAgent &#125; &#125; render() &#123; return ( &lt;div&gt; Hello World &#123;this.props.userAgent&#125; &lt;/div&gt; ) &#125;&#125; Next提供了一个新的生命周期：getInitialProps 只允许用于pages，不支持子组件中使用 在页面加载时执行，并将返回的Object作为props 页面首次加载只会在服务端执行，之后通过路由API或者Link组件跳转，才会在客户端执行 接收一个context对象，包含： pathname - path section of URL query - query string section of URL parsed as an object asPath - String of the actual path (including the query) shows in the browser req - HTTP request object (server only) res - HTTP response object (server only) err - Error object if any error is encountered during the rendering Static file serving 根目录下创建static文件夹 通过’/static/xxx’引用静态文件 建议按照这个约定来，后面方便使用官方提供的配置项配置cdn Note: Don’t name the static directory anything else. The name is required and is the only directory that Next.js uses for serving static assets. next.config.js1234567891011121314151617181920212223const withCSS = require(&apos;@zeit/next-css&apos;)const withImages = require(&apos;next-images&apos;)const pkg = require(&apos;./package.json&apos;)const isDev = process.env.NODE_ENV !== &apos;production&apos; // node环境module.exports = withCSS(withImages(&#123; distDir: isDev ? &apos;build&apos; : &apos;_next&apos;, // Setting a custom build directory generateBuildId: async () =&gt; `v$&#123;pkg.version&#125;`, // Configuring the build ID assetPrefix: !isDev ? &apos;https://xxx&apos; : &apos;&apos;, // add CDN assetPrefix in the production. cssModules: true, publicRuntimeConfig: &#123; // config Will be available on both server and client ... &#125;, webpack: config =&gt; &#123; // Fixes npm packages that depend on `fs` module config.node = &#123; fs: &apos;empty&apos;, &#125; return config &#125;,&#125;)) head 、document、errorhead12345678910import Head from &apos;next/head&apos;const Layout = (&#123; title, children &#125;) =&gt; ( &lt;div style=&#123;&#123; fontSize: &apos;0.3rem&apos; &#125;&#125;&gt; &lt;Head&gt; &lt;title&gt;&#123;title&#125;&lt;/title&gt; &lt;/Head&gt; &#123;children&#125; &lt;/div&gt;) 为避免标签重复，可以使用key属性 _document.js123456789101112131415161718192021222324import Document, &#123; Html, Head, Main, NextScript &#125; from &apos;next/document&apos;class MyDocument extends Document &#123; static async getInitialProps(ctx) &#123; const initialProps = await Document.getInitialProps(ctx) return &#123; ...initialProps &#125; &#125; render() &#123; return ( &lt;Html&gt; &lt;Head&gt; &lt;style&gt;&#123;`body &#123; margin: 0 &#125; /* custom! */`&#125;&lt;/style&gt; &lt;/Head&gt; &lt;body className=&quot;custom_class&quot;&gt; &lt;Main /&gt; &lt;NextScript /&gt; &lt;/body&gt; &lt;/Html&gt; ) &#125;&#125;export default MyDocument Is rendered on the server side Is used to change the initial server side rendered document markup Commonly used to implement server side rendering for css-in-js libraries like styled-components or emotion. styled-jsx is included with Next.js by default. _error.js404 或 500 错误 next会自动渲染到内置的error.js. 若希望自定义error页面，创建_error.js即可 12345678910111213141516class Error extends React.Component &#123; static getInitialProps(&#123; res, err &#125;) &#123; const statusCode = res ? res.statusCode : err ? err.statusCode : null; return &#123; statusCode &#125; &#125; render() &#123; return ( &lt;p&gt; &#123;this.props.statusCode ? `An error $&#123;this.props.statusCode&#125; occurred on server` : &apos;An error occurred on client&apos;&#125; &lt;/p&gt; ) &#125;&#125; next-routes 为了简化next原生路由系统在动态路由的规划上复杂的部分 符合Express风格的路由参数匹配 方便为请求处理添加中间件 主要还是看着清爽、用着也简单 123456const routes = require(&apos;next-routes&apos;)module.exports = routes() .add(&#123; name: &apos;a&apos;, pattern: &apos;/a&apos;, page: &apos;a&apos; &#125;) .add(&#123; name: &apos;b&apos;, pattern: &apos;/b&apos;, page: &apos;b&apos; &#125;) .add(&#123; name: &apos;c&apos;, pattern: &apos;c/:id&apos;, page: &apos;c&apos; &#125;) lru-cache 基于“最近最少使用”的服务端缓存 ssr过程]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>React</tag>
        <tag>SSR</tag>
        <tag>next.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Verdaccio的npm私服]]></title>
    <url>%2F2018%2F06%2F12%2F%E5%9F%BA%E4%BA%8EVerdaccio%E7%9A%84npm%E7%A7%81%E6%9C%8D%2F</url>
    <content type="text"><![CDATA[在日常开发过程中，我们经常会使用到npm包，也就是出现在我们的package.json中的种种依赖，亦是node_modules中的一个个文件夹。这些包大多来自npm公网仓库。随着公司的业务越来越复杂，项目迭代速度也越来越快，我们可能会去开发公司内部的组件库或类似的东东。在没有npm私有仓库之前，我们都是手动复制一些开发完的公共组件代码到相关的项目中，这样操作比较繁琐也不利于更新维护，因此我们需要一个npm私有仓库存放相关公用的组件及模块。同时这些组件库或者代码可能涉及公司内部信息或其他原因，导致其是不能对外开放的，因此我们有必要搭建一个类似于npmjs的私有平台来管理公司业务相关的组件及代码。换句话说，我们需要在公司内部搭建一个npm仓库来管理我们自己的npm包。 Verdaccio 是什么Verdaccio是一个轻量级私有NPM的Registry（fork自Sinopia，但Sinopia已基本停止更新维护） npm私服搭建的必要性 1.如果公司处于隐私保护的需要，不想将内部生产的包推到npm社区，但又急需要一套完整的包管理工具来管理越来越多的组件、模块等。对于前端，npm是前端包管理的不二选择 2.从npmjs上下载包非常慢；利用私服，项目中使用的所有包可以缓存在上面，然后大家下包的时候走私服，不用走npmjs了，速度提升明显。 3.对于下载和发布npm包都有了相应的权限管理 搭建&amp;发布过程 verdaccio must be installed globaly 全局安装verdaccio包123npm install -g verdaccio或者：yarn global add verdaccio 修改配置文件verdaccio的特点是:你在哪个目录运行，它就会在对应的目录下创建有关文件。目录下默认有两个文件：config.yaml和storage，另外htpasswd是添加用户之后自动创建的；第一次启动默认的config文件位置在 /Users/xxx/.config/verdaccio/config.yaml(该配置文件将在下方详述。) 在配置文件最后添加监听端口:1listen: 0.0.0.0:4873 # listen on all addresses 启动verdaccioverdaccio直接启动123verdaccio或者：verdaccio --listen xxxx --config ~./config.yaml // 指定端口和配置文件 pm2守护verdaccio进程利用第一种方法虽然可以正常启动和使用verdaccio，但不建议用这种方式启动verdaccio，我们可以用pm2来使用pm2对verdaccio进程进行托管启动。使用pm2托管的进程可以保证进程永远是活着的,方便查看进程状态、日志等。 安装pm21npm install -g pm2 --unsafe-perm 使用pm2启动verdaccio1pm2 start verdaccio 查看pm2下的verdaccio信息1pm2 show verdaccio 实时日志：1tail -f /xxx/.pm2/logs/verdaccio-out-0.log 更过pm2的内容看参考pm2 添加用户123456npm adduser --registry http://xxx.xxx.com/ //后面是我们的私服地址类似如下：Username: yanghePassword: xxxxxxEmail: (this IS public) xxxx@qq.comLogged in as rong on http://xxx.xxx.com/. 然后在verdaccion启动页面尝试登录即可，默认登录后有发布包的权限。(这里可以通过修改config.yaml配置文件来对权限进行设置) 发布&amp;删除npm包12345npm publish #已经切换到我们私服地址的情况下npm publish --registry http://xxx.xxx.com/ #未切换到我们的私服时，直接--registry指定私服地址删除发布的包npm unpublish --force xxxx 配置文件详解123456789101112131415161718192021// 配置文件原文：storage: ./storageauth:htpasswd: file: /.htpasswduplinks:npmjs: url: http://registry.npmjs.org/packages:&apos;@*/*&apos;: access: $all publish: $authenticated&apos;*&apos;: access: $all publish: $authenticated proxy: npmjslogs:- &#123;type: stdout, format: pretty, level: http&#125;listen: 0.0.0.0:4873http_proxy: http://代理服务器ip:8080https_proxy: http://代理服务器ip:8080 常用配置详解： ● storage： 仓库保存的地址，publish时仓库保存的地址。 ● auth： htpasswd file：账号密码的文件地址，初始化时不存在，可指定需要手工创建。max_users：默认1000，为允许用户注册的数量。为-1时，不允许用户通过npm adduser注册。但是，当为-1时，可以通过直接编写htpasswd file内容的方式添加用户。 ● 语法：用户名:{SHA}哈希加密的字符=:autocreated 时间 ● 加密算法：SHA1哈稀之后再转换成 Base64 输出就好 ● uplinks: 配置上游的npm服务器，主要用于请求的仓库不存在时到上游服务器去拉取。 ● packages: 配置模块。access访问下载权限,publish包的发布权限。格式如下：scope:权限：操作scope:两种模式 ○ 一种是 @/ 表示某下属的某项目 ○ 另一种是 * 匹配项目名称(名称在package.json中有定义) ● 权限： ○ l access: 表示哪一类用户可以对匹配的项目进行安装(install) ○ l publish: 表示哪一类用户可以对匹配的项目进行发布(publish) ○ l proxy: 如其名，这里的值是对应于 uplinks 的名称，如果本地不存在，允许去对应的uplinks去取。 ● 操作： ○ l $all 表示所有人(已注册、未注册)都可以执行对应的操作 ○ l $authenticated 表示只有通过验证的人(已注册)可以执行对应操作，注意，任何人都可以去注册账户。 ○ l $anonymous 表示只有匿名者可以进行对应操作（通常无用） ○ l 或者也可以指定对应于之前我们配置的用户表 htpasswd 中的一个或多个用户，这样就明确地指定哪些用户可以执行匹配的操作听端口和主机名。 ■ localhost:4873 #默认 ■ 0.0.0.0:4873 #在所有网卡监听 ● 代理 #http_proxy: http://something.local/ #http代理 #https_proxy: https://something.local/ #https代理 #no_proxy: localhost,127.0.0.1 #不适用代理的iP 修改了配置文件后，运行命令: verdaccio -c config.yml nrmnrm是npm registry管理工具, 能够查看和切换当前使用的registry。不安装也可以，安装会更高效。 安装nrm1yarn global add nrm 添加私服地址到nrm管理工具这里的xxx是我们给自己的私服地址起的别名，为了切换和使用方便。 1nrm add xxx http://xxx.xxx.com/ #添加本地私服地址 将npm包的下载地址改到xxx私服。1nrm use xxx 使用nrm ls可查到我们可以使用的所有镜像源地址，* 后面是当前使用的; nrm del可删除设置的registry。 npm配置配置方式 1.通过npm的config指令；（用来管理npm的配置文件，通过config命令配置的项目实际上是通过更新配置文件npmrc来配置的） 2.通过修改npm命令的配置文件npmrc文件； 配置文件的位置： 1.用户配置文件：npm config get userconfig查看文件路径(~/.npmrc) 2.全局配置文件：npm config get globalconfig查看文件路径(/etc/npmrc) 3.内置配置文件: 安装npm的目录下的npmrc文件(/usr/local/lib/node_modules/npm/npmrc) 命令行操作1234567npm config set &lt;key&gt; &lt;value&gt; [-g|--global] //给配置参数key设置值为value；npm config get &lt;key&gt; //获取配置参数key的值；npm config delete &lt;key&gt; //删除置参数key及其值；npm config list [-l] //显示npm的所有配置参数的信息；npm config edit //编辑配置文件npm get &lt;key&gt; //获取配置参数key的值；npm set &lt;key&gt; &lt;value&gt; [-g|--global] //给配置参数key设置值为value； 配置npm registry的方式 1.通过给npm 命令添加注册源选项: npm --registry=https://registry.npm.taobao.org [npm命令] 2.通过npm的config命令配置指向国内镜像源: npm config set registry https://registry.npm.taobao.org //配置源为淘宝的源 3.在配置文件.npmrc 文件写入源地址：registry=https://registry.npm.taobao.org //写入.npmrc配置文件]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos2dx 记录]]></title>
    <url>%2F2018%2F05%2F12%2FCocos2dx-%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Creator编辑器 AnySDK多渠道打包工具 起源自Cocos2D-iPhone，创始人Ricardo Quesada。Cocos2D-X创始人王哲。 背后公司为触控科技，起步于2008年初创建的CocoaChina社区，专注于苹果产品和iOS系统开发，后推出开源2D 游戏引擎 Cocos2d。 官方的关于我们 所有分支游戏引擎均是MIT许可证下发布。 Cocos2dxX代表着Cross，即交叉。因为Cocos2D-X为开发者提供了跨平台支持，通过C++语言把游戏逻辑一次编写即可编译到iOS、Android以及更多手机平台上运行。Cocos2D-X在中国拥有70%的开发者认可和使用比例。此外，Cocos2D-X在全球199个国家地区有40万开发者使用，而Cocos2D-X已经成为全球使用率最高的手机游戏引擎之一，在中国前10名收入最高的手机游戏产品中有8款产品是由Cocos2D-X引擎及工具开发的。 现在看到的都是 v3.x 版本。3.x 和2.x相比，改动非常大。 Cocos2d-html5Cocos2d-JS的一个重要模块，是一个面向Web的游戏引擎，采用Canvas或者WebGL渲染，并完全兼容HTML5规范，所以基于Cocos2d-JS开发的游戏天然可运行在所有支持HTML5规范的浏览器 Cocos2dx-js FullVersion 全平台编译发布官网：1.1 Cocos2d-JS介绍 简单粗暴说就是用 Js 写，full version 可以js 写完后编译到全部平台：web 版翻译到 WebGl 或者 Canvas，使用的是 Cocos2dx-h5渲染；其他安卓、iOS、window等等均等于使用 js 调用底层 API, 使用的解析器是 SpiderMonkey。 JavaScript代码由Mozilla的JavaScript虚拟机SpiderMonkey进行解析和运行，同时这个虚拟机被改造为支持Cocos2d-x的类型，数据结构和对象。SpiderMonkey本身是由C/C++开发的，不仅可嵌在浏览器中，也嵌入到任何C++的程序中使用。SpiderMonkey负责脚本的解析运行，创建和检查JavaScript的数据结构，处理各种错误，提供安全检查，调试脚本的功能，并通过JSAPI实现C++代码的调用。通过这项技术，可让开发者能用纯JavaScript来开发原生游戏，游戏的开发更加高效，原型构建和验证更加便捷。 注：这种一般我都认为不靠谱，搜了下反馈确实不太靠谱。 Cocos2dx-js LiteVersion 只做 Web 如果您只关注于纯Web游戏开发，那么您还可以选择Cocos2d-JS Lite的版本，Lite版本提供Cocos2d-html5单引擎文件，可自由定制功能，并可直接嵌入到HTML页面可以开始游戏开发，提供更加简便的工作流，开发更加便捷，还兼具脚本文件体积小，性能高效等优点，具体的内容见后续的工作流章节的介绍。 Cocos CreatorCocos Creator 用户手册 cocos2d-x是游戏开发框架，Cocos Creator才称得上是完整的游戏引擎。 — 王哲 看了一小时 Cocos2dx 的文档我是拒绝的。看文档的时候就发现Cocos出过好几代编辑器， 但之前的槽点都很多。而直接下载引擎代码开发，打开一看简直毛骨悚然。但是看了下 Cocos Creator，感觉很惊艳。 Cocos Creator 官方介绍 Q: Cocos Creator 是游戏引擎吗？A: 它是一个完整的游戏开发解决方案，包括了 cocos2d-x 引擎的 JavaScript 实现（不需要学习一个新的引擎），以及能让你更快速开发游戏所需要的各种图形界面工具Q: Cocos Creator 的编辑器是什么样的？A: 完全为引擎定制打造，包含从设计、开发、预览、调试到发布的整个工作流所需的全功能一体化编辑器Q: 我不会写程序，也能使用 Cocos Creator 吗？A: 当然！Cocos Creator 编辑器提供面向设计和开发的两种工作流，提供简单顺畅的分工合作方式。Q: 我使用 Cocos Creator 能开发面向哪些平台的游戏？A: Cocos Creator 目前支持发布游戏到 Web、Android 和 iOS，以及点开即玩原生性能的 Cocos Play 手机页游平台，真正实现一次开发，全平台运行。 知乎上有人 po 出了他们公司的使用感想 可以直接在 Chrome 中进行调试，即改即见，非常顺畅。 Web平台：canvas 或者 webGL 可选 支持 VS Code 管理和编辑项目脚本代码，可以轻松实现语法高亮、智能代码提示等功能。支持配置脚本一键编译。配置代码编辑环境 搜到的各种负面反馈 cocos2dx 总在不断大改，持续学习成本高。【确实，cocos2dx 文档非常一般。但 Cocos Creator 文档非常完善。 游戏从业者认为 jsbinding 性能要求绝对不能符合要求【但我们不是做游戏哇感觉 web 就够了 2016年才发布，应该是存在了很多坑，具体可参见如何评价 Cocos2d-x 的新编辑器 Cocos Creator？ 场景开发节点 &amp; 组件Cocos Creator 的工作流程是以组件式开发为核心的，组件式架构也称作 组件-实体系统（或 Entity-Component System），简单的说，就是以组合而非继承的方式进行实体的构建。 在 Cocos Creator 中，节点（Node）是承载组件的实体，我们通过将具有各种功能的 组件（Component） 挂载到节点上，来让节点具有各式各样的表现和功能。接下来我们看看如何在场景中创建节点和添加组件。 坐标系 &amp; 变换笛卡尔坐标系 世界坐标系（World Coordinate）和本地坐标系（Local Coordinate）； 每个节点以父节点来算本地坐标系；本地坐标系会最后转成世界坐标系。 锚点（Anchor） 是节点的另一个重要属性，它决定了节点以自身约束框中的哪一个点作为整个节点的位置。我们选中节点后看到变换工具出现的位置就是节点的锚点位置。 脚本开发1234567891011121314cc.Class(&#123; extends: cc.Component, properties: &#123; &#125;, // use this for initialization onLoad: function () &#123; &#125;, // called every frame, uncomment this function to activate update callback update: function (dt) &#123; &#125;,&#125;); 生命周期onLoadstartupdatelateUpdateonDestroyonEnableonDisable 动作系统 动作系统并不能取代动画系统，动作系统提供的是面向程序员的 API 接口，而动画系统则是提供在编辑器中来设计的。同时，他们服务于不同的使用场景，动作系统比较适合来制作简单的形变和位移动画，而动画系统则强大许多，美术可以用编辑器制作支持各种属性，包含运动轨迹和缓动的复杂动画。 动作列表 网络接口脚本引用支持 ES2015 TypeScript 模块化脚本 &amp; 插件脚本 脚本加载顺序如下： Cocos2d 引擎 插件脚本（有多个的话按项目中的路径字母顺序依次加载）[可以用于配置 普通脚本（打包后只有一个文件，内部按 require 的依赖顺序依次初始化） 目标平台兼容性插件发布后将直接被目标平台加载，所以请检查插件的目标平台兼容性，否则项目发布后插件有可能不能运行。目标平台不提供原生 node.js 支持例如很多 npm 模块都直接或间接依赖于 node.js，这样的话发布到原生或网页平台后是不能用的。依赖 DOM API 的插件将无法发布到原生平台网页中可以使用大量的前端插件，例如 jQuery，不过它们有可能依赖于浏览器的 DOM API。依赖这些 API 的插件不能用于原生平台中。 子系统前几个系统应该是设计师重点要看的。 图像和渲染自带的各种组件，绘图系统、外部资源家在，还有摄像头。 UI系统多分辨率适配 动画这个动画编辑器感觉忒难用。。。 物理碰撞summary使用 Cocos Creator 做教研配套目前来看的优势 &amp; 劣势。 还需要确定的点： 是否能够插入我们自己的统计和用户代码等？如果编译到原生，是否丢失？【目前尝试 js 应该是可以的，但原生那边不知道怎么处理，此外存在兼容问题 如何放到视频上进行交互？【视频上的是否直接使用 其他js 库更好。 进一步的需求有哪些？ 优势： 工作流非常顺畅，且可以设计和程序分工合作，都可以直接看到效果。 配套文档很赞。可以考虑通过培训，建立设计师和程序都可使用的完整开发流程。 可以直接打包生成资源包上线。 花了几个小时跟着文档写了下demo，感觉上手度不错。 劣势 需要培训。设计师需要学会游戏设计，如果运营来做的话也需要一定的基础。此外脚本方面也需要学习游戏脚本开发设计，需要熟悉游戏开发术语、流程、Cocos2dx-js 的 API 等。 流程上的磨合可能会耗费一定时间和精力，这边的人基本都没有做过游戏开发。 目前发布不到两年，在持续迭代，需要踩坑。 太复杂的成本可能会比较大，例如踩到内存的坑 目前技术积累为0。 有组件库等可能会好一些。c Reference cocos 官网]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Cocos2dx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron新手入门]]></title>
    <url>%2F2018%2F02%2F11%2FElectron%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[这篇分享旨在初步介绍Electron，重点介绍其中的几个主要概念，让没有接触过Electron的开发者有一个入门的基础认知。 如果你还未接触过Electron，请看之前某乎上一篇装逼的Title：感谢 Electron，我现在有了两个身份：前端开发 和 桌面客户端开发。 基本概念是什么 官方概念：Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。 通俗理解：让你用纯 JavaScript 调用丰富的原生 APIs 创造桌面应用。使用 web 页面作为 GUI，你能把它看作一个被 JavaScript 控制的，精简版的 Chromium 浏览器。 依赖项更新（Chromium &amp; Node） Electron中Chromium的版本通常会在Chromium发行新的稳定版后的一到两周之内更新，具体时间根据升级所需的工作量而定。 为了使版本更加稳定，Electron通常会在Node.js发布了新版本的一个月之后再更新。 补充：为了保持Electron的小巧，Electron只用了Chromium的渲染库而不是其全部组件。 这使得升级Chromium更加容易，但也意味着Electron缺少了Google Chrome里的一些浏览器相关的特性。 特点 Web 技术 基于 Chromium 和 Node.js, 让你可以使用 HTML, CSS 和 JavaScript 构建应用。 跨平台 兼容 Mac, Windows 和 Linux， 它构建的应用可在这三个操作系统上面运行。 解决哪些困难 自动更新: autoUpdater 原生的菜单和通知: menu 崩溃报告: crashReporter 调试和性能分析: contentTracing … 与web项目的主要区别electron核心可以分成2个部分:主进程和渲染进程。 主进程连接着操作系统和渲染进程； 渲染进程就是我们所熟悉前端环境； 传统的web环境不能对系统进行操作，而electron相当于node环境，我们可以在项目里使用所有的node api； 目录结构抽象your-app/|── package.json|── main.js|── index.html 主进程 &amp; 渲染进程 运行 package.json 的 main 脚本的进程被称为主进程。 在主进程中运行的脚本通过创建web页面来展示用户界面。 一个 Electron 应用总是有且只有一个主进程； Electron 中的每个 web 页面运行在它自己的渲染进程中。 在普通的浏览器中，web页面通常在一个沙盒环境中运行，不被允许去接触原生的资源。 然而 Electron 的用户在 Node.js 的 API 支持下可以在页面中和操作系统进行一些底层交互。 区别 主进程使用 BrowserWindow 实例创建页面。 每个 BrowserWindow 实例都在自己的渲染进程里运行页面； 主进程管理所有的web页面和它们对应的渲染进程； 页面中调用与 GUI 相关的原生 API 是不被允许的，对应的渲染进程必须与主进程进行通讯，请求主进程进行相关的 GUI 操作； 举例1.主进程操作 12345const &#123;BrowserWindow&#125; = require('electron')// 主进程创建web页面let someWindow = new BrowserWindow(winOpts)// 加载本地的文件someWindow.loadURL('file://' + __dirname + '/index.html') 2.渲染进程操作12345678const &#123;BrowserWindow&#125; = require('electron').remoteconst modalPath = 'xxxxxx'let win = new BrowserWindow(&#123; width: 400, height: 320 &#125;)win.on('close', () =&gt; &#123; win = null &#125;)win.loadURL(modalPath)win.show() 进程间通信在web页面，不允许调用原生GUI相关的API，因为在web页面管理原生GUI资源是很危险的，会很容易泄露资源。如果你想在web页面施行GUI操作，web页面的渲染进程必须要与主进程通信，请求主进程来完成这些操作。 ipc模块（渲染进程 -&gt; 主进程）使用ipcMain和ipcRenderer模块，在渲染进程中使用ipcRender模块向主进程发送消息，主进程中ipcMain接收消息，进行操作;如果需要反馈，则通知渲染进程，渲染进程根据接收的内容执行相应的操作。 1.主进程123456const &#123;ipcMain&#125; = require('electron')ipcMain.on('close-window', (evt, data) =&gt; &#123; console.log(data) evt.sender.send('replymsg', otherData);&#125;); 2.渲染进程123456const &#123;ipcRenderer&#125; = require('electron')ipcRender.send('close-window', data);ipcRender.on('replaymsg', (evt, otherData) =&gt; &#123; console.log(otherData)&#125;) 不过切忌用 ipc 传递大量的数据，会有很大的性能问题，严重会让你整个应用卡住。 remote模块在渲染进程中使用主进程模块。为渲染进程和主进程通信提供了一种简单方法。 使用 remote 模块, 你可以调用 main 进程对象的方法, 而不必显式发送进程间消息。 12345// 渲染进程中const &#123;BrowserWindow&#125; = require('electron').remotelet win = new BrowserWindow(&#123;width: 800, height: 600&#125;)win.loadURL('https://ke.youdao.com') webContents（主进程 -&gt; 渲染进程）主进程主动向渲染进程发送消息。1this.webviewWindow.webContents.send('main-process-messages'); ipcRenderer.sendTo（渲染进程 -&gt; 渲染进程）渲染进程互相发送通信。1ipcRenderer.sendTo(windowId, 'xxx-message', 'data') 菜单（Menu &amp; MenuItem）对桌面应用来说，另一个重要的概念就是菜单栏。分为上下文菜单（右击菜单），托盘菜单（绑定到托盘图标），应用菜单（在OS X上）等多种。 1.主进程中123456789101112131415161718192021222324252627282930313233const &#123;app, Menu&#125; = require('electron') const template = [ &#123; label: 'Edit', submenu: [ &#123;role: 'undo'&#125;, &#123;role: 'redo'&#125;, &#123;type: 'separator'&#125;, &#123;role: 'cut'&#125;, &#123;role: 'copy'&#125; ] &#125;, &#123; role: 'window', submenu: [ &#123;role: 'minimize'&#125;, &#123;role: 'close'&#125; ] &#125;, &#123; role: 'help', submenu: [ &#123; label: 'Learn More', click () &#123; require('electron').shell.openExternal('https://electronjs.org') &#125; &#125; ] &#125; ] const menu = Menu.buildFromTemplate(template) Menu.setApplicationMenu(menu) 2.渲染进程中1234567const &#123;remote&#125; = require('electron')const &#123;Menu, MenuItem&#125; = remoteconst menu = new Menu()menu.append(new MenuItem(&#123;label: 'MenuItem1', click() &#123; console.log('item 1 clicked') &#125;&#125;))menu.append(new MenuItem(&#123;type: 'separator'&#125;))menu.append(new MenuItem(&#123;label: 'MenuItem2', type: 'checkbox', checked: true&#125;)) Shellshell 模块提供与桌面集成相关的功能, 使用默认应用程序管理文件和 url。 在文件管理器中显示给定的文件 将给定的文件移动到垃圾箱 播放哔哔的声音 … 12345678910// 打开系统文件目录const &#123;shell&#125; = require('electron')const os = require('os')shell.showItemInFolder(os.homedir())// 使用默认浏览器打开urlconst &#123;shell&#125; = require('electron')shell.openExternal('http://electron.atom.io') 调试渲染进程调试最广泛使用来调试指定渲染进程的工具是Chromium的开发者工具集，可以通过编程的方式在BrowserWindow的webContents中调用openDevTool()API来打开它们或者注册快捷键。123456789const &#123; BrowserWindow &#125; = require('electron')let win = new BrowserWindow()win.webContents.openDevTools()// 或者globalShortcut.register('Alt+CommandOrControl+I', () =&gt; &#123; BrowserWindow.getFocusedWindow().toggleDevTools();&#125;) 主进程调试（vscode）这里我们介绍如何利用vscode来调试Electron主进程。 步骤： 使用vscode打开electron项目 点击debug 添加配置 打开launch.json点击右下角的添加配置，添加“electron 主” 在主进程（main.js）添加断点，点击“启动”进行调试1234567891011121314&#123; // 修改launch.json文件最终为 "version": "0.2.0", "configurations": [ &#123; "type": "node", "request": "launch", "name": "Electron Main", "runtimeExecutable": "$&#123;workspaceFolder&#125;/node_modules/.bin/electron", "program": "$&#123;workspaceFolder&#125;/main.js", "protocol": "inspector" &#125; ]&#125; 注意：”protocol”: “legacy” //添加默认的协议是legacy，这个协议导致不进入断点，改为：“inspector” 打包第三方打包工具 electron-packager electron-forge electron-builder 举例（electron-packager）1234567// location of project是你项目文件夹的位置，// name of project定义你的项目名，// platform决定要构建的平台（*all* 包括Windows，Mac和Linux ），// architecture决定构建哪个构架下（x86或x64，all表示两者），// electron version让你选择要用的Electron版本electron-packager &lt;location of project&gt; &lt;name of project&gt; &lt;platform&gt; &lt;architecture&gt; &lt;electron version&gt; &lt;optional options&gt; 第一次打包用时比较久，因为要下载平台的二进制文件，随后的打包将会快的多。 与 React or Vue 集成 electron-react-boilerplate electron-vue 总结 Electron 并不是很复杂，在写完不多的主进程代码后，其他的业务代码几乎和Web应用没什么区别，甚至可以将一个线上应用迅速的包装成为一个客户端应用，比如electronic-wechat。 采坑不可避免，比如在打包、集成flash等方面等等； 基本不考虑兼容性（只需要兼容 Chromium 浏览器） 渲染进程调试和在浏览器中调试完全一致。多个web页面，每个都可以打开对应了调试工具，你可以和浏览器调试一样查看DOM、查看log、监听网络请求等等。 最后多说一句：虽然Electron 的进程间通信很方便，而且支持多窗口，但我墙裂倾向于使用 Electron 构建单窗口应用。 参考资料 官方doc 用Electron开发桌面应用 electron-quick-start electron-api-demos awesome-electron]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Electron</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebRTC初探]]></title>
    <url>%2F2017%2F11%2F09%2FWebRTC%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[WebRTC WebRTC (Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。跨平台。The WebRTC initiative is a project supported by Google, Mozilla and Opera, amongst others. This page is maintained by the Google Chrome team. 参见知乎上一个回答：https://www.zhihu.com/question/25497090/answer/43395462 自然这套API是带传输功能的。所以获取图像信源之后不应该用websocket发送图像数据，而是直接用WebRTC的通信相关API发送图像和声音（这套API是同时支持图像和声音的）数据。所以，正确的方法是什么呢？1、你得有一个实现了WebRTC相关协议的客户端。比如Chrome浏览器。2、架设一个类似MCU系统的服务器。（不知道MCU是什么？看这：MCU（视频会议系统中心控制设备））第一步，用你的客户端，比如Chrome浏览器，通过WebRTC相关的媒体API获取图像及声音信源，再用WebRTC中的通信API将图像和声音数据发送到MCU服务器。第二步，MCU服务器根据你的需求对图像和声音数据进行必要的处理，比如压缩、混音等。第三步，需要看直播的用户，通过他们的Chrome浏览器，链接上你的MCU服务器，并收取服务器转发来的图像和声音流。 peer to peer “Peer”在英语里有“对等者”和“伙伴”的意义。因此，从字面上，P2P可以理解为对等互联网。国内的媒体一般将P2P翻译成“点对点”或者“端对端”，学术界则统一称为对等计算。P2P可以定义为：网络的参与者共享他们所拥有的一部分硬件资源（处理能力、存储能力、网络连接能力、打印机等），这些共享资源通过网络提供服务和内容，能被其它对等节点(Peer)直接访问而无需经过中间实体。在此网络中的参与者既是资源（服务和内容）提供者（Server），又是资源获取者（Client）。—- protocols 协议 ICE (Interactive Connectivity Establishment)互动式连接建立是由IETF的MMUSIC工作组开发出来的一种framework，可整合各种NAT穿透技术，如STUN、TURN（Traversal Using Relay NAT，中继NAT实现的穿透）、RSIP（Realm Specific IP，特定域IP）等。该framework可以让SIP的客户端利用各种NAT穿透方式打穿远程的防火墙。 NAT (Network Address Translation)在计算机网络中，网络地址转换（Network Address Translation，缩写为NAT），也叫做网络掩蔽或者IP掩蔽（IP masquerading），是一种在IP数据包通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。这种技术普遍使用在有多台主机但只通过一个公有IP地址访问因特网的私有网络中。 STUN（Session Traversal Utilities for NAT）NAT会话穿越应用程序是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间创建UDP通信。该协议由RFC 5389定义。 TURN（Traversal Using Relay NAT）TURN是一个client-server协议。TURN的NAT穿透方法与STUN类似，都是通过取得应用层中的公有地址达到NAT穿透。但实现TURN client的终端必须在通讯开始前与TURN server进行交互，并要求TURN server产生”relay port”，也就是relayed-transport-address。这时TURN server会建立peer，即远端端点（remote endpoints），开始进行中继（relay）的动作，TURN client利用relay port将资料传送至peer，再由peer转传到另一方的TURN client。 SDP (Session Description Protocol)会话描述协议（Session Description Protocol或简写SDP）描述的是流媒体的初始化参数。此协议由IETF发表为 RFC 2327。 API由于兼容性问题，请现加载 adapter https://github.com/webrtc/adapter/ getUserMedia()https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getUserMedia 1navigator.getUserMedia(constraints, successCallback, errorCallback); constranits 一个包含了video 和 audio两个成员的MediaStreamConstraints 对象，用于说明请求的媒体类型。 回调拿到的是一个 stream 对象，参见MediaStream Interface MediaRecorder()RTCPeerConnectionmethod: RTCPeerConnection(): RTCPeerConnection的初始化函数 createOffer(): 生成一个offer，它是一个带有特定的配置信息寻找远端匹配机器（peer）的请求 123456pc1.createOffer( offerOptions).then( onCreateOfferSuccess, onCreateSessionDescriptionError) createAnswer():在协调一条连接中的两端offer/answers时，根据从远端发来的offer生成一个answer。 setLocalDescription(): 改变与连接相关的本地描述。 setRemoteDescription(): 改变与连接相关的远端描述。 createDataChannel(): 在一条连接上建立一个新的RTCDataChannel（用于数据发送）。这个方法把一个数据对象作为参数，数据对象中包含必要的配置信息。 dataConstraint: https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createDataChannel 传输基于 SCTP WebRTC的通讯终端需要获取和交换本地及远程的视频音频信息，例如分辨率等；这一类 metadata 数据在onCreateAnswerSuccess等方法接收到的参数中以 SDP 的格式传送。 event: onicecandidate: 当一个 RTCICECandidate 对象被添加时，这个事件被触发。 oniceconnectionstatechange: 当iceConnectionState 改变时，这个事件被触发。 onaddstream: 当MediaStream 被远端机器添加到这条连接时，该事件会被触发。 how to establish a p2p connection 每个端创建一个RTCPeerConnection, 添加从getUserMedia()获取到的 stream 获取网络信息，找到潜在的连接点，也就是ICE candidates. 获取和分享本地及远程描述, metadata about local media in SDP format. demo 中没有 server, 实际参考 WebRTC in the real world: STUN, TURN and signaling Reference https://webrtc.org/ https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API Peer to Peer 综述 http://www.intsci.ac.cn/users/luojw/P2P/index.html]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>webrtc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端视频autoplay+playsinline小结]]></title>
    <url>%2F2017%2F09%2F06%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%A7%86%E9%A2%91autoplay-playsinline%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在移动端开发中我们会遇到音视频相关的功能需求，而针对不同系统、不同厂商的移动设备、不同浏览器环境，音视频在移动端的表现存在不少差异，这些差异体现在UI、交互、默认属性表现等方面。这里我针对移动端的video元素在自动播放和内联播放两方面进行相关实验，比较不同环境的差异并作出记录，以备后用。 自动播放仅设置autoPlay1&lt;video width="320" height="240" controls src="http://www.w3school.com.cn/i/movie.mp4" autoplay="autoplay"&gt;&lt;/video&gt; 原生 微信 微博 QQ UC 搜狗 360 360极速 IOS N N N N N N N N Android Y N N Y N N Y N 设置autoPlay + muted1&lt;video width="320" height="240" controls src="http://www.w3school.com.cn/i/movie.mp4" autoplay="autoplay" muted&gt;&lt;/video&gt; 原生 微信 微博 QQ UC 搜狗 360 360极速 IOS N N N N N N N N Android Y N 不定 Y N N Y N video.play()主动触发12345&lt;video width="320" height="240" controls src="http://www.w3school.com.cn/i/movie.mp4" id="v1"&gt;&lt;/video&gt; setTimeout(() =&gt; &#123; document.getElementById('v1').play() &#125;, 1000); 原生 微信 微博 QQ UC 搜狗 360 360极速 IOS N N N Y N N N N Android Y N N Y N N Y N WeixinJSBridgeReady事件触发play()123456789&lt;video width="320" height="240" controls src="http://www.w3school.com.cn/i/movie.mp4" id="v1"&gt;&lt;/video&gt; document.addEventListener( 'WeixinJSBridgeReady', function() &#123; document.getElementById('v1').play() &#125;, false ) IOS微信支持，Android微信不支持 取消全屏播放设置playsinline1&lt;video width="320" height="240" controls src="http://www.w3school.com.cn/i/movie.mp4" webkit-playsinline="true" playsinline="true"&gt;&lt;/video&gt; 原生 微信 微博 QQ UC 搜狗 360 360极速 IOS Y Y N Y N Y 诡异 Y Android Y Y Y Y Y Y Y Y ios微博取消全屏，可以用 https://www.npmjs.com/package/iphone-inline-video]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React+Mobx+videojs重构web直播系统]]></title>
    <url>%2F2017%2F08%2F01%2F%E5%9F%BA%E4%BA%8Evideojs%E7%9A%84web%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F%E9%87%8D%E6%9E%84%2F</url>
    <content type="text"><![CDATA[在正式入职之后接手的第一个重点项目便是web直播系统的重构。因为在实习期间一直参与旧版直播系统的迭代开发，同时因旧版本技术栈相对陈旧、代码维护成本过高、扩展能力较弱等原因，决定于2018年进行彻底重构，针对UI做出重新设计。整体系统比较简单，主体由视频和讨论区两大元素构成，在技术选型上采用React作为UI层框架，Mobx作为状态管理库，videoJs作为视频播放器类库。本文针对重构过程中涉及的主要技术点进行记录，留作今后查缺补漏。 技术选型 Mobx 无论是Redux / MobX ，均是开源的状态管理库，用状态描述 UI 界面，与 React 都不具有强绑定关系 store Mobx-react 绑定库 主要提供API：Provider &amp; inject &amp; observer redux react-redux mobx mobx-react 装饰器 @表示装饰器，可以在 ES7 或者 TypeScript 类属性中使用。Mobx中装饰器的使用并非必须，只是语法稍有区别。 Babel默认情况下是不支持装饰器的，需配置相应plugin: !!注意， plugins 属性中: transform-decorators-legacy 应放在最前面。当使用 react native 时，可用下面的预设来代替 transform-decorators-legacy: H5的video标签基本使用H5中的video标签可以进行视频播放，写一个video设置一个src属性指定媒体源地址就可以实现媒体播放了。针对低版本浏览器video的HTML结构也提供了友好的兼容方案，只需要在video标签内写上不兼容时要展示的HTML内容即可。 video的属性 src: 视频地址controls: 控制条； poster: 视频下载时显示的图像； preload: 预加载； playsinline: 防止ios用户视频播放自动全屏。 x-webkit-airplay=“allow” : 支持ios的AirPlay功能； x5-video-orientation: 声明播放器支持的方向； x5­-video­-player­-fullscreen:全屏设置； 媒体格式目前原生H5支持的媒体格式主要有MP4、OGG、WebM、M3U8等，但各大浏览器厂商之间对媒体格式的支持各不相同： canPlayType API可以通过HTMLVideoElement的canPlayType API进行当前环境的格式兼容判断: ‘probably’: The specified media type appears to be playable. ‘maybe’: Cannot tell if the media type is playable without playing it. ‘ ‘ :The specified media type definitely cannot be played. 环境差异 UI不一致 API实现与支持程度不一致（标准API里的controls、poster、autoplay…未必有效） 事件交互行为不一致（播放进度变化、事件触发频率不同、部分事件触发时相应状态值未必可靠、部分场景缺少事件..） 媒体格式的支持无法保证 Video.js简介Video.js 是一个通用的在网页中嵌入视频播放器的 JS 库，自动检测浏览器对 HTML5 的支持情况，如果不支持则自动使用 Flash 播放器。（目前版本：v6.5.0） 优点： 开源免费（https://github.com/videojs/video.js）。 2.接入简单（几分钟即可完成基础配置，搭建视频页面）。 3.几乎兼容所有主流浏览器，并优先使用html5；在不支持的浏览器中，会自动使用flash进行播放。 界面可定制、插件可扩展。 注意： v6.0.0版本之前：默认将flash build在sdk中; v6.0.0版本之后：需手动引入官方提供的flash tech（https://github.com/videojs/videojs-flash）; Skins &amp; Icons &amp; Plugins Skinning 播放器样式完全通过html+css构建，可以通过覆盖基础css样式进行调整； Icons 除此之外，videoJS本身固有的几个class如果灵活运用，可以减少部分细节处理工作量 vjs-live-control // 展示直播状态 vjs-poster // 展示默认图 vjs-seeking // 展示加载中loading vjs-controls-enabled // 展示控制条 vjs-controls-disabled //隐藏所有的控制组件 vjs-ended // 播放结束样式 vjs-error // 视频异常展示错误信息 … Plugins Video.js 本身很简单，支持基础的播放功能和特性。任何复杂或高级特性将以插件形式提供，比如：播放列表、分析、广告和支持先进的格式如HLS等。(http://videojs.com/plugins/) Video.js 提供强大而丰富的插件同时，你也可以自己创建插件并发布。 1.插件方法中的this指向所创建plugin依附的videojs实例； 2.插件方法中可以使用任何videojs API进行相关处理； 3.例如在直播系统中：有关视频的日志上报、各种播放器事件监听处理等，均可放到单独的插件中，方便组织代码； Step 1: Write Some Javascript Step 2: Registering A Plugin Step 3: Using A Plugin 初始化 方式一： 方式二：（推荐） 配置参数一般，对于播放器的初始化，除了传入必备的视频源地址以及视频格式之外，videoJS支持配置额外的options。如： 直播type：’rtmp/flv’ 录播type：’video/mp4’ 常用API 常用事件 主要事件的处理 loadstart：标识播放器开始加载视频，在这里可以展示加载中状态、设置定时器判定首次加载是否成功; error：标识播放器异常，一般原因有网络异常、视频解码异常等，此时进行主动拉流操作，并在多次尝试拉流失败后给出用户提示； canplaythrough、 play、playing、 seeked：都可能标识视频已正常播放，此时应对错误提示、加载中提示、切换线路提示等UI进行隐藏调整； waiting：标识视频发生卡顿较为准确的事件，可以在此处进行视频卡顿次数的记录并展示卡顿提示等信息； pause：标识视频暂停，可以做一些UI（如：预览、控制条等）方面的显隐操作; timeupdate：标识视频进行中位置发生改变，可在此完成协同播放时间的其他界面操作; ended：标识视频播放结束，可做一系列资源回收、清理工作，或者结束提示、循环播放等操作； stalled：标识视频资源不可用，这时应进行主动拉流或者提示用户切换线路等操作（但要注意：在部分浏览器中，视频长时间处于暂停状态后可能也会触发此事件，这是应该忽略）； 其他视频播放监控 视频异常播放器提供的error事件回调基本涵盖了绝大多数异常情况，包括视频格式无法解析、视频源错误、网络异常、拉流超时等； 视频首次加载过程当音频/视频处于首次加载过程中时，大致会发生以下事件： 1.play、playing、canplaythrough三个事件不一定都会触发，顺序也并不固定； 2.不同浏览器中（如Edge）可能直接触发到seeked事件即加载完成开始播放，并不会有play、playing、canplaythrough这些； durationchange有时候会在loadstart事件之前触发； 视频首次加载&amp;卡顿 这里的关键在于定时器到期后判断视频是否处于正常状态 在web直播系统中,我们针对视频首次加载是否成功，视频播放中产生的卡顿进行监测记录： 1.首次加载：从loadstart事件开始若干秒内视频是否加载成功； 2.卡顿：从waiting事件触发后若干秒内是否恢复正常播放； 其他问题小结 Video.networkState() 判断网络状态 0 = NETWORK_EMPTY - 音频/视频尚未初始化 1 = NETWORK_IDLE - 音频/视频是活动的且已选取资源，但并未使用网络 2 = NETWORK_LOADING - 浏览器正在下载数据 3 = NETWORK_NO_SOURCE - 未找到音频/视频来源 在开发中遇到这种情况：直播时，如果web端直接断开网络连接，视频播放器是不会抛出任何异常事件的，这时如果我们想为用户提供主动拉流，需要监测网络状态变化。Video.networkState经试验并不可取，无论网络异常与否，都会从0或2最终变化到1。（最后通过监听offline &amp; online事件获取网络状态变化） video.addTextTrack() addTextTrack方法创建和返回新的文本轨道。 新的TextTrack对象会被添加到视频/音频元素的文本轨道列表中。 浏览器支持程度：所有主流浏览器都不支持addTextTrack方法。 IE浏览器，每次暂停再开始或快进/退视频，视频倍速会被自动重置为1倍速]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>React</tag>
        <tag>直播</tag>
        <tag>Mobx</tag>
        <tag>VideoJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitPage+Hexo建站]]></title>
    <url>%2F2017%2F04%2F01%2FGitPage-Hexo%E5%BB%BA%E7%AB%99%2F</url>
    <content type="text"><![CDATA[这里简要记录 GitPage + Hexo 快速建立个人站点的过程。建站方式很多，依托的平台不尽相同，我选择GitPage+Hexo，其具有操作简单、维护成本低、文档详细等优势。网上已经有很多此类教程，此文并无过多创新，仅在记录自己建站中的操作步骤、相关参考文档等，力求简明扼要。 环境 mac os 10.11.6 node v8.14.0 yarn v1.13.0 git v2.10.1 hexo v3.8.0 next v7.0.1 GitHub创建Pages项目创建一个名称为{yourusername}.github.io的新仓库即可。其中的 yourusername 填写自己的用户名，Github会识别并自动将该仓库设为Github Pages。用户主页是唯一的，填其他名称只会被当成普通项目。 分支管理Github Pages部署分支设置中，一般分为： master 分支 gh-pages 分支（需要手动创建） 我的做法： blog-src 分支用于存放源码 master 分支用于部署 Hexo安装1$ yarn global add hexo-cli 创建hexo项目1$ hexo init [projectname] 拉取Github项目到本地1$ git clone https://github.com/yourusername/yourprojectname.git 把之前生成的hexo项目文件夹下的内容全部复制过来。 常用命令 hexo init [folder]: 新建项目 hexo new [post_title]: 新建文章 hexo generate [-d]: 生成静态文件 hexo serve [-p port]: 启动本地服务器。默认访问网址为： http://localhost:4000/ hexo deploy [-g]: 部署 hexo clean: 清除缓存 具体参考：hexo命令 更文步骤启本地服务 - 新建&amp;编写文章 - 生成静态文件 - 部署 具体参考：hexo写作 配置_config.yml主要是针对网站的基本信息配置，比如网站(副)标题、描述等。 具体参考：hexo配置 更换主题这里我采用hexo的next主题，另外还有非常多主题可供选择，详见hexo-themes 具体参考： theme-next 下载1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 修改项目配置根目录下的_config.yml中，theme：next 修改主题配置这里罗列出我进行的主要个性化配置:（themes/next下的_config.yml） favicon footer menu scheme avatar auto_excerpt sidebar back2top social third party services 具体参考：theme-next doc 备注 github添加公钥 如果是首次在一台机器进行部署（或更换了环境），记得在github添加公钥。具体参考：使用Github SSH Key以免去Hexo部署时输入密码]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>GitPage</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
