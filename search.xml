<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[那些年我们一起追过的mpvue]]></title>
    <url>%2F2019%2F01%2F10%2Fmpvue%E9%87%87%E5%9D%91%2F</url>
    <content type="text"><![CDATA[这里我们并不会深入讲述小程序开发;这次分享刚刚走到小程序开发的大门口，门口有你、有我、有坑;鲁迅说过：世上本没有坑，踩的人多了就有了坑; what is mpvue ?mpvue 是一个使用 Vue.js 开发小程序的前端框架。框架基于 Vue.js 核心，mpvue 修改了 Vue.js 的 runtime 和 compiler 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验。 全局安装 vue-cli1$ npm install --global vue-cli vue cli 之于 vue creact-react-app 之于 react 题外话：vue-cli &amp; @vue/cli * 两者其实是一个东西 从3.0开始：从 vue-cli 更名为 @vue/cli 如果你使用vue cli 3，官方要求：“ Vue CLI requires Node.js version 8.9 or above (8.11.0+ recommended) ” 12345// cli 2npm install -g vue-cli // cli 3npm install -g @vue/cli 两个版本的详细区别这里不做重点，我们只说创建项目 12345// cli 2vue init &lt;template-name&gt; &lt;project-name&gt; // cli 3vue create &lt;project-name&gt; 因为mpvue官方提供的是基于模板(template)初始化项目，而vue cli3不再直接支持；同时官方也为我们提供了在3的基础上使用template的方式：安装一个全局桥 初始化mpvue 创建一个基于 mpvue-quickstart 模板的新项目 12// 新手一路回车选择默认就可以了$ vue init mpvue/mpvue-quickstart my-project 安装依赖 123$ cd my-project$ npm install$ npm run dev 如果你和我一样使用nvm管理本地node版本，必须手动nvm use xx切换一次 *（e.g.哪怕当前就是在node 8版本下也要手动执行一次nvm use 8），否则初始化mpvue项目时就会失败：报错 vue-cli · [.eslintrc.js] Missing helper: “if_eq” 生成目录结构 导入微信开发者工具 如果我们按照官方指引一步步导入，是不能正常跑起来项目的，会报错：未找到入口 app.json 文件，或者文件读取失败，请检查后重新编译。 原因在：project.config.json * 这个文件是用来存储项目配置的，每次微信开发者工具导入mpvue项目后会依据这个配置文件去加载项目； 那么我们看这个文件里有这样一条配置项：”miniprogramRoot”: “dist”, 它就是告诉微信开发者工具：这个目录下有我打包好的微信小程序，你快去加载 补充：app.json是什么 * app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等； 它是必须的！（而我们去看打包好的dist目录下哪里有app.json？？只有一个wx目录，自然会报错找不到） 解决办法：更改project.config.json中的miniprogramRoot项为”dist/wx”，这样微信开发者工具就会自动去这个目录下加载小程序所需资源；亦或者直接导入dist/wx目录自然也是可以的 补充：只有直接导入dist/wx目录才能使用预览功能，原因未知 页面配置 app.json中的pages字段设定了当前小程序包含的页面（相当于路由），其中以^开头的会作为小程序首页对待，否则默认出现在pages数组的第一项为首页； 我们看到对应pages目录下分布着一个个页面，每个里面都有一个main.js，并且内容极其相似甚至完全一样； 另外，官方Q&amp;A中关于页面配置提到一点： mpvue本身页面配置的缺陷： • mpvue新增页面或者模块的时候必须重新npm run dev才可以进行更新，不支持热更新;（官方告诉我们要忍） • mpvue所有页面模块除了.vue文件外，都需要写一个很类似的main.js，重复工作; 推荐一个第三方的插件：mpvue-entry 该插件使得我们新建页面时只需要一个.vue文件，并且将页面路由通过一个js文件统一配置 优点：集中式页面配置，自动生成各页面的入口文件，优化目录结构 mpvue-entry根据官方的readme，我们一步步来： 安装：npm i mpvue-entry -D 使用 修改webpack.base.conf.js 新增pages.js配置文件 调整原来的pages目录结构（去掉冗余的main.js） 对应修改app.json的pages配置！！！ 在官方readme里我们注意到： v1.5.0 版本开始支持 mpvue-loader@^1.1.0 版本，新版 src 目录下需存在 app.json 文件，预计 v2.0 版本不再兼容旧版 mpvue-loader 编译通过，导入微信开发者工具,报错了： 未找到入口 app.json 文件，或者文件读取失败，请检查后重新编译。* 仔细查看：dist/wx中的app.json怎么搬家跑到上层去了？！ 原因有二： 官方指引中让务必删去的配置部分导致本该复制到dist/wx目录下的app.json没有被复制； mpvue-entry帮我们在dist目录下生成了一个app.json 怎么办呢？ * 办法一（不能完美解决）：先把刚刚“务必删去”的配置部分加回来；结果：存在两个app.json,而且还稍有不同① mpvue-entry帮我们在dist目录下生成的app.json多了个subPackages项:分包；稍后会讲到。② mpvue-loader帮我们在dist/wx下生成了一个app.json,就是src/app.json的复制品；③ pages.js中关于单页面的配置(标题等)不生效 对于单个页面的配置：官方提供的方法是: 通过在每个page的main.js中export独立的配置： 12345export default &#123; config: &#123; navigationBarTitleText: &apos;第二页标题&apos; &#125;&#125; （main.js都给干掉了，pass！并且我测试了一下在不接入mpvue-entry的情况下这个方法也是无效的，需要在每个page目录下新建一个main.json文件进行配置） 但还是有办法的：通过调用 wx API 动态设置； 12345onLoad() &#123; wx.setNavigationBarTitle(&#123;‘title’: ‘xxxx’ &#125;)&#125; 真正的解决办法：mpvue_entry应该支持构建路径可配置啥的，于是往下翻文档，果不其然： 一切似乎在朝着更好的方向发展：只有一个app.json了 &amp; 单页面的配置生效了 但我们仔细看在dist/wx下构建出的app.json是和src/app.json一模一样的（它实际是mpvue-loader复制过去的，覆盖了mpvue-entry构建出来的app.json） ！！这就解释了为何mpvue-entry要求务必删去webpack.base.conf.js中复制json的配置 分包刚刚我们跳过了一个概念：分包。它的功效类比于webpack打包出来的多个chunk 每个使用分包小程序必定含有一个主包。主包就是包含启动页面的包。 在小程序启动时，默认会下载主包进入首页，当用户进入分包内某个页面时，客户端才会把对应分包下载下来，下载完成后再进行展示。 对小程序进行分包，可以优化小程序首屏时间 接入vuex 1.安装依赖：yarn add vuex 2.state &amp; getters &amp; mutations &amp;actions等基础配置 3.入口处添加store 补充：Logger &amp; 严格模式 1.Logger plugin 因为在微信开发者工具中没有 vue-devtools，最好在开发模式下配置vuex的logger插件，方便观察状态变化； 2.严格模式 在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。 不要在发布环境下启用严格模式！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。 如果你并未接入mpvue-entry，最初的项目中接入vuex后，是会遇到问题的： 入口处无法通过new Vue({store, …App})这种形式传入store 必须在每个page下的main.js中注入才能生效;(也有绕过去的办法，就是在入口处通过Vue.prototype.$store = store绑定store，这样在每个子page中就可以访问到store了 网络请求 说明：微信小程序的 js运行环境和浏览器不同，页面的脚本逻辑是在JsCore中运行，JsCore是一个没有窗口对象的环境，访问不了window，也没有XmlhttpRequest等对象；所以像jquery 、zepto、axios这些在小程序中都不能直接使用 方案一： 封装wx.request（不再赘述，参考微信官方文档） 方案二：Flyio 一个支持所有JS运行环境的基于Promise的、支持请求转发、强大的http请求库。可以在多端最大限度的实现代码复用。 目前支持的平台包括：Node.js 、微信小程序 、Weex 、React Native 、Quick App 和浏览器。 番外不支持部分复杂的 JavaScript 渲染表达式官方举例是这样的： 123456789// 这种就不支持，建议写 computed&lt;p&gt;&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;/p&gt;// 但写在 @event 里面的表达式是都支持的，因为这部分的计算放在了 vdom 里面&lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt; &lt;div @click=&quot;clickHandle(item, index, $event)&quot;&gt;&#123;&#123; item.value &#125;&#125;&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 12比如&lt;h4&gt;当前值：&#123;&#123;number&#125;&#125;&lt;/h4&gt;是可以的；&lt;h4&gt;&#123;&#123;`当前值：$&#123;number&#125;`&#125;&#125;&lt;/h4&gt;就会报错: number is undefined 页面关闭后，重进数据状态并未初始化这个是mpvue已知的问题，开发者正在解决（但其实已经很久了仍未解决）解决办法就是利用一些生命周期钩子重新初始化一次数据，如： 1234onHide() &#123; // 退出页面时候 this.reset()&#125; 生命周期钩子 created：小程序加载后，所有页面的created钩子都会被调用，而且只调用这一次；可以用小程序的onLoad钩子代替（在每个页面进入后执行一次） mounted：page A -&gt; page B -&gt; page A，此时页面A的mounted钩子不会被触发，因为小程序的历史页面不会被销毁；如果有需要每次页面展示都要调用的逻辑，可以使用小程序的onShow代替 小心后台页面的js小程序中可能有n个页面，所有的这些页面，虽然都拥有自己的webview， 但是却共享同一个js运行环境。当你从A跳到B，A的定时器等js操作仍在进行，并且不会被销毁，并且会抢占B页面的资源。 在h5的环境中，当我们跳转到其他页面，老页面的js环境会被自动销毁，定时器什么都被销毁掉了，因此我们不需要关心老页面中还有哪些js代码可能还会执行。但是在小程序中，我们必须手动的“清理”掉这样的代码。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Vue</tag>
        <tag>小程序</tag>
        <tag>mpvue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next.js初探]]></title>
    <url>%2F2018%2F12%2F30%2Fnext-js%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>React</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React单元测试实战]]></title>
    <url>%2F2018%2F12%2F08%2FReact%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[什么是单元测试 在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；==对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法==。 通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到软件规格书要求的工作目标，没有程序错误；虽然单元测试不是什么必须的，但也不坏，这牵涉到项目管理的政策决定。每个理想的测试案例独立于其它案例；为测试时隔离模块，经常使用stubs、mock或fake等测试马甲程序。==单元测试通常由软件开发人员编写，用于确保他们所写的代码匹配软件需求和遵循开发目标==。它的实施方式可以是非常手动的（透过纸笔），或者是做成构建自动化的一部分。 一个软件越容易写单元测试，就表明它的模块化结构越好，模块之间的耦合越弱。React的组件化和函数式编程，天生适合进行单元测试。 为什么要写单元测试 测试可以确保得到预期的结果，改代码更自信 有单元测试的代码，通常是更好的代码 写单元测试的时候，会更深入的认识代码； 为了更方便的写单元测试，组件拆分更合理。 所有代码变动都是可预期的 更好的提升自我 写单测的开发更靠谱 更好的吹牛逼（我的单元测试覆盖率是100%） 评级加分 Jest &amp;&amp; EnzymeJestJest是Facebook发布的一个开源的、基于Jasmine框架的JavaScript单元测试工具。提供了包括内置的测试环境DOM API支持、断言库、Mock库等，还包含了Spapshot Testing、 Instant Feedback等特性。用来测试包括React应用在内的所有JavaScript代码。 优点 提供控制台实时反馈测试结果 提供内置的测试环境DOM API支持、断言库、Mock库、代码覆盖率报告 Snapshot测试：Jest能够对React组件树进行序列化，生成对应的字符串快照，通过比较字符串提供高性能的UI检测 执行速度快 无需配置 丰富的api，完善的文档 在线使用 可以使用repl.it来在线尝试Jest。想想怎么用add ()函数来相加两个数。我们可以编写一个简单的测试，通过 add-test.js来验证 1 + 2 等于 3。输入”run”立马尝试。 EnzymeEnzyme是Airbnb开源的React测试类库，提供了一套简洁强大的API，并通过jquery风格的方式进行dom处理，开发体验十分友好。不仅在开源社区有超高人气，同时也获得了React官方的推荐。 为啥除了Enzyme又要配合Jest呢？ 因为要编写测试用例的话，光有测试类库还不够，还需要测试运行环境、断言库、mock库等等工具辅以支持；Jest把这些统统囊括。 常用api介绍Enzyme api shallow渲染 shallow: 返回App的浅渲染 浅渲染指的是，将一个组件渲染成虚拟DOM对象，但是只渲染第一层，不渲染所有子组件，所以处理速度非常快。它不需要DOM环境，因为根本没有加载进DOM。 find(selector): 返回指定ShallowWrapper组件 123456789component.find(&apos;.my-class&apos;); // by class namecomponent.find(&apos;#my-id&apos;); // by idcomponent.find(&apos;td&apos;); // by tagcomponent.find(&apos;div.custom-class&apos;); // by compound selectorcomponent.find(&apos;[bar=false]&apos;); // by prop selectorcomponent.find(TableRow); // by react component constructorcomponent.find(&apos;TableRow&apos;); // by react component&apos;s displayname at(index): 返回指定位置的子组件 get(index): 返回指定位置的子组件的DOM节点 props(): 返回根组件的所有属性 prop(key): 返回根组件的指定属性 state([key]): 返回根组件的状态 setState(nextState): 设置根组件的状态 setProps(nextProps): 设置根组件的属性 simulate(event[, …args]): 模拟事件 debug() 1console.log(wrapper.find(&apos;Ueditor&apos;).debug()) 它跟shallow方法非常像，主要的不同是采用了第三方HTML解析库Cheerio，它返回的是一个Cheerio实例对象。 render渲染 render: 将React组件渲染成静态的HTML字符串，然后使用Cheerio这个库分析这段HTML代码的结构，返回一个Cheerio对象。 mount渲染 mount: 完全渲染 将React组件加载为真实DOM节点，用到了jsdom来模拟浏览器环境。用于测试： - 需要跟dom api交互的组件 - 被高阶组件包装的组件 Jest api globals api describe(name, fn)：描述块，讲一组功能相关的测试用例组合在一起，test suite it(name, fn, timeout)：别名test，用来放测试用例，test case afterAll(fn, timeout)：所有测试用例跑完以后执行的方法 beforeAll(fn, timeout)：所有测试用例执行之前执行的方法 afterEach(fn)：在每个测试用例执行完后执行的方法 beforeEach(fn)：在每个测试用例执行之前需要执行的方法 expect api expect.toMatchSnapshot() expect.toBeCalledWith(arg1, arg2, …) expect.toEqual(value) expect.toBe(value)，相当于=== mock api jest.fn(): mock function jest.fn().mockResolvedValue(value): 异步mock promise的resolve jest.fn().mockRejectedValue(new Error(‘Async error’)): 异步mock promise的reject Jest命令行 运行所有测试(默认) 1jest or 1npm test 运行监视模式 12npm test --watch // 默认运行基于 hg/git (未提交的文件) 修改的文件的测试npm test --watchAll 生成测试覆盖率报告 1npm test --coverage 测试脚本编写1234567891011import React from &apos;react&apos;import &#123;shallow&#125; from &apos;enzyme&apos;import toJson from &apos;enzyme-to-json&apos;import App from &apos;./App&apos;describe(&apos;App&apos;, () =&gt; &#123; // test suite it(&apos;test default props&apos;, () =&gt; &#123; // test case const wrapper = shallow(&lt;App /&gt;) expect(toJson(wrapper)).toMatchSnapshot() &#125;)&#125;) snapshot引入’enzyme-to-json’，使用toJson方法，快照会生成一个组件的UI结构。jest在执行的时候，如果发现toMatchSnapshot方法，会在同级目录下生成一个snapshots文件夹,以字符串的形式存放快照文件。 以后每次测试的时候都会和第一次生成的快照进行字符串比较来判断UI是否改变。因为是字符串比较，所以性能很高。 1234567891011121314151617181920212223242526272829303132// 上文中代码生成的snapshotexports[`App test default props 1`] = `&lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot; &gt; &lt;img alt=&quot;logo&quot; className=&quot;App-logo&quot; src=&quot;logo.svg&quot; /&gt; &lt;p&gt; Edit &lt;code&gt; src/App.js &lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className=&quot;App-link&quot; href=&quot;https://reactjs.org&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot; &gt; Learn React &lt;/a&gt; &lt;/header&gt;&lt;/div&gt;`; 当两次快照内容不同时，可以手动修复问题解决。如果是你期望的改动，则可以直接使jest –updateSnapshot来更新快照文件。也可以在监视模式下直接按’u’来更新快照。 优点 不用写大量的断言判断ui，自动生成 异常时给出详细的错误信息，方便调试 一键更新，无需重写测试用例 万物皆可snapshot snapshot不是万能的 snapshot不能覆盖100% snapshot不能替代其他单元测试方法 其他测试优先级 独立不依赖，常用组件 辅助性组件，utils 更复杂组件 不需要测试 第三方库 常量 内联样式(不会改变组件的行为) 高阶组件(HOC) 代码覆盖率代码覆盖率是一个测试指标，用来描述测试用例的代码是否都被执行。统计代码覆盖率一般要借助代码覆盖工具，Jest内置代码覆盖工具。 四个测量维度 行覆盖率(line coverage)：是否测试用例的每一行都执行了 函数覆盖率(function coverage)：是否测试用例的每一个函数都调用了 分支覆盖率(branch coverage)：是否测试用例的每个if代码块都执行了 语句覆盖率(statement coverage)：是否测试用例的每个语句都执行了 HOC connect(container)antd pro推荐这种做法： 被 dva connect 的 React 组件可以使用下面方式进行测试。 1234567891011import React from &apos;react&apos;import &#123; shallow &#125; from &apos;enzyme&apos;import Dashboard from &apos;./Dashboard&apos;it(&apos;renders Dashboard&apos;, () =&gt; &#123; // 使用包装后的组件 const wrapper = shallow( &lt;Dashboard.WrappedComponent user=&#123;&#123; list: [] &#125;&#125; /&gt; ) expect(wrapper.find(&apos;Table&apos;).props().dataSource).toEqual([])&#125;) 关于Component.WrappedComponent The wrapped component is exposed as the static property WrappedComponent on the returned component, which can be used for testing the component in isolation, among other things. 123456// MyComponent.jsexport default withRouter(MyComponent)// MyComponent.test.jsimport MyComponent from &apos;./MyComponent&apos;render(&lt;MyComponent.WrappedComponent location=&#123;&#123;...&#125;&#125; ... /&gt;) HOC withRouter(container)redux官方推荐这种做法： 1234567import &#123; connect &#125; from &apos;react-redux&apos;​// Use named export for unconnected component (for tests)export class App extends Component &#123; /* ... */ &#125;​// Use default export for the connected component (for app)export default connect(mapStateToProps)(App) mock dispatch1const dispatch = jest.fn().mockResolvedValue(&apos;default&apos;) 总结 Jest + Enzyme 写单元测试快速方便 Snapshot简单易用，在不追求测试覆盖率的情况下，可以简单写几个snapshot 单元测试对于写更好的代码，很有帮助 参考文献 https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95 https://jestjs.io/docs/zh-Hans/getting-started.html https://airbnb.io/enzyme/ http://react-china.org/t/jest-enzyme-react/11769 https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#initializing-test-environment https://www.youtube.com/watch?v=8Ww2QBVIw0I&amp;feature=youtu.be https://github.com/ned-alyona/posts/tree/master/jest-enzyme-testing https://juejin.im/post/5b6c39bde51d45195c079d62 http://echizen.github.io/tech/2017/04-24-component-lifycycle-test https://medium.com/@newyork.anthonyng/use-jest-snapshot-on-everything-4c5d4c88ca16 https://hackernoon.com/snapshot-testing-react-components-with-jest-744a1e980366 https://blog.bitsrc.io/how-to-test-react-components-using-jest-and-enzyme-fab851a43875 https://pro.ant.design/docs/ui-test-cn https://cn.redux.js.org/docs/recipes/WritingTests.html https://hackernoon.com/testing-react-components-with-jest-and-enzyme-41d592c174f https://github.com/r-walsh/react-unit-test-practice]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>单测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles使用二三事]]></title>
    <url>%2F2018%2F07%2F26%2FCharles%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[平时开发过程中我们经常会遇到bug页面白屏了或者出现了异常的数据展示等等问题，这时候我们经常会想到的debug方式便是抓包。而抓包我们可以使用多种工具来实现，这里我常用的是charles,在使用过程中发现他有诸多有点和奇技淫巧方便我们debug，在此做下笔记。 Charles是什么它一个对Mac系统非常友好的抓包工具（付费），使用场景包括线上/测试/本地/接口的代理，在APP里测试本地页面，手机同域host代理。 安装&amp;破解 参考： http://charles.iiilab.com/ 开始使用开启代理依次点击 Proxy &gt; macOS Proxy 默认是127.0.0.1 8888端口 PC抓包此时打开任意浏览器，访问网址，就可以在charles里面看到发出的请求了。界面有两种显示方式：Structure 和Sequence，前者按照域名的路径结构树罗列请求，后者按照时间显示每一个请求，可以按照自己的需求自行选择喜欢的查看方式。顶部的按钮是一些常用功能，左起第一个扫帚button功能是清空请求记录，第二个红色录制button的功能是开始/停止抓包的切换。 在content标签页可以查看某个请求的详细信息，包括cookies，query等。 Sequence 显示界面有filter输入框可以过滤出你想要查看的请求。 手机抓包在手机上设置当前wifi为手动代理，host为charles所在pc的ip，端口8888。这样手机的所有请求就会被charles捕获到。同时，我们经常在开发中为了带上cookie、避免跨域将本机host修改为test.youdao.com，手机通过charles代理后，就免去了在手机上修改host的麻烦，直接可以访问电脑上可以访问的内容。 https抓包charles设置SSL代理Proxy &gt;SL Proxying Setting &gt; Enable SSL Proxying 弹出ssl编辑窗口，将enable ssl Proxying勾选上。 点击add按钮，添加新的规则，我们粗暴的设置为匹配任何域名的443端口，当然你可以指定抓取某个域名下的https请求。 PC安装证书 Help &gt; SSL Proxying &gt; install Charles Root certificate 添加证书 选择始终信任该证书 手机安装证书 Help &gt; SSL Proxying &gt; install Charles Root certificate on a Mobile Device or Remote Browser 在移动设备上添加证书，弹出窗口 手机访问 http://chls.pro/ssl 下载证书。 IOS 10.3以前的版本需要在 设置 &gt; 通用 &gt; 描述文件与设备管理 验证描述文件 IOS 10.3 以后的版本还要在 设置 &gt; 通用 &gt; 关于本机 &gt; 证书信任设置 &gt; 找到 charlesCA 然后信任该证书 Map Remote这是我最喜欢的一个功能，简单说就是将任何请求映射到你想要的请求，可以是 本地服务-&gt;远程，xxx.com/api/get -&gt; yyy.com/api/get 远程-&gt;远程, xxx.com/api/get -&gt; yyy.com/api2/get2 远程-&gt;本地服务，xxx.com/api/get -&gt; yyy.com/api2/get2 文件-&gt;文件，xxx.com/index.html -&gt; yyy.com/index2.html 正则匹配路径-&gt;指定路径，xxx.com/api/* -&gt; yyy.com/api2/ 因此可以自由地实现很多功能, 本地开发使用线上API；线上地址访问本地开发代码调试bug；在APP中访问本地开发服务。相对应的Charles提供Map Local 功能，使用方法与Map Remote类似，只不过是将远程服务映射到本地绝对路径，不需要本地启服务。 开启 Map Remote Tools &gt; Map Remote 弹出设置窗口，勾选enable map remote，点击add按钮添加规则。 Map from 是你想要匹配映射的地址，设置协议，域名，路径，query等，Map to 是映射的目标网址，就是你真正想要访问的地址。 这条规则的意思是将A:23441/路径下的所有请求，映射到本地服务 B:8080/ 路径下 eg：A/index.html-&gt; B:8080/index.html A:23441/api/get?q=a-&gt; B:8080/api/get?q=a]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Verdaccio的npm私服]]></title>
    <url>%2F2018%2F06%2F12%2F%E5%9F%BA%E4%BA%8EVerdaccio%E7%9A%84npm%E7%A7%81%E6%9C%8D%2F</url>
    <content type="text"><![CDATA[在日常开发过程中，我们经常会使用到npm包，也就是出现在我们的package.json中的种种依赖，亦是node_modules中的一个个文件夹。这些包大多来自npm公网仓库。随着公司的业务越来越复杂，项目迭代速度也越来越快，我们可能会去开发公司内部的组件库或类似的东东。在没有npm私有仓库之前，我们都是手动复制一些开发完的公共组件代码到相关的项目中，这样操作比较繁琐也不利于更新维护，因此我们需要一个npm私有仓库存放相关公用的组件及模块。同时这些组件库或者代码可能涉及公司内部信息或其他原因，导致其是不能对外开放的，因此我们有必要搭建一个类似于npmjs的私有平台来管理公司业务相关的组件及代码。换句话说，我们需要在公司内部搭建一个npm仓库来管理我们自己的npm包。 Verdaccio 是什么Verdaccio是一个轻量级私有NPM的Registry（fork自Sinopia，但Sinopia已基本停止更新维护） npm私服搭建的必要性 1.如果公司处于隐私保护的需要，不想将内部生产的包推到npm社区，但又急需要一套完整的包管理工具来管理越来越多的组件、模块等。对于前端，npm是前端包管理的不二选择 2.从npmjs上下载包非常慢；利用私服，项目中使用的所有包可以缓存在上面，然后大家下包的时候走私服，不用走npmjs了，速度提升明显。 3.对于下载和发布npm包都有了相应的权限管理 搭建&amp;发布过程 verdaccio must be installed globaly 全局安装verdaccio包123npm install -g verdaccio或者：yarn global add verdaccio 修改配置文件verdaccio的特点是:你在哪个目录运行，它就会在对应的目录下创建有关文件。目录下默认有两个文件：config.yaml和storage，另外htpasswd是添加用户之后自动创建的；第一次启动默认的config文件位置在 /Users/xxx/.config/verdaccio/config.yaml(该配置文件将在下方详述。) 在配置文件最后添加监听端口:1listen: 0.0.0.0:4873 # listen on all addresses 启动verdaccioverdaccio直接启动123verdaccio或者：verdaccio --listen xxxx --config ~./config.yaml // 指定端口和配置文件 pm2守护verdaccio进程利用第一种方法虽然可以正常启动和使用verdaccio，但不建议用这种方式启动verdaccio，我们可以用pm2来使用pm2对verdaccio进程进行托管启动。使用pm2托管的进程可以保证进程永远是活着的,方便查看进程状态、日志等。 安装pm21npm install -g pm2 --unsafe-perm 使用pm2启动verdaccio1pm2 start verdaccio 查看pm2下的verdaccio信息1pm2 show verdaccio 实时日志：1tail -f /xxx/.pm2/logs/verdaccio-out-0.log 更过pm2的内容看参考pm2 添加用户123456npm adduser --registry http://xxx.xxx.com/ //后面是我们的私服地址类似如下：Username: yanghePassword: xxxxxxEmail: (this IS public) xxxx@qq.comLogged in as rong on http://xxx.xxx.com/. 然后在verdaccion启动页面尝试登录即可，默认登录后有发布包的权限。(这里可以通过修改config.yaml配置文件来对权限进行设置) 发布&amp;删除npm包12345npm publish #已经切换到我们私服地址的情况下npm publish --registry http://xxx.xxx.com/ #未切换到我们的私服时，直接--registry指定私服地址删除发布的包npm unpublish --force xxxx 配置文件详解123456789101112131415161718192021// 配置文件原文：storage: ./storageauth:htpasswd: file: /.htpasswduplinks:npmjs: url: http://registry.npmjs.org/packages:&apos;@*/*&apos;: access: $all publish: $authenticated&apos;*&apos;: access: $all publish: $authenticated proxy: npmjslogs:- &#123;type: stdout, format: pretty, level: http&#125;listen: 0.0.0.0:4873http_proxy: http://代理服务器ip:8080https_proxy: http://代理服务器ip:8080 常用配置详解： ● storage： 仓库保存的地址，publish时仓库保存的地址。 ● auth： htpasswd file：账号密码的文件地址，初始化时不存在，可指定需要手工创建。max_users：默认1000，为允许用户注册的数量。为-1时，不允许用户通过npm adduser注册。但是，当为-1时，可以通过直接编写htpasswd file内容的方式添加用户。 ● 语法：用户名:{SHA}哈希加密的字符=:autocreated 时间 ● 加密算法：SHA1哈稀之后再转换成 Base64 输出就好 ● uplinks: 配置上游的npm服务器，主要用于请求的仓库不存在时到上游服务器去拉取。 ● packages: 配置模块。access访问下载权限,publish包的发布权限。格式如下：scope:权限：操作scope:两种模式 ○ 一种是 @/ 表示某下属的某项目 ○ 另一种是 * 匹配项目名称(名称在package.json中有定义) ● 权限： ○ l access: 表示哪一类用户可以对匹配的项目进行安装(install) ○ l publish: 表示哪一类用户可以对匹配的项目进行发布(publish) ○ l proxy: 如其名，这里的值是对应于 uplinks 的名称，如果本地不存在，允许去对应的uplinks去取。 ● 操作： ○ l $all 表示所有人(已注册、未注册)都可以执行对应的操作 ○ l $authenticated 表示只有通过验证的人(已注册)可以执行对应操作，注意，任何人都可以去注册账户。 ○ l $anonymous 表示只有匿名者可以进行对应操作（通常无用） ○ l 或者也可以指定对应于之前我们配置的用户表 htpasswd 中的一个或多个用户，这样就明确地指定哪些用户可以执行匹配的操作听端口和主机名。 ■ localhost:4873 #默认 ■ 0.0.0.0:4873 #在所有网卡监听 ● 代理 #http_proxy: http://something.local/ #http代理 #https_proxy: https://something.local/ #https代理 #no_proxy: localhost,127.0.0.1 #不适用代理的iP 修改了配置文件后，运行命令: verdaccio -c config.yml nrmnrm是npm registry管理工具, 能够查看和切换当前使用的registry。不安装也可以，安装会更高效。 安装nrm1yarn global add nrm 添加私服地址到nrm管理工具这里的xxx是我们给自己的私服地址起的别名，为了切换和使用方便。 1nrm add xxx http://xxx.xxx.com/ #添加本地私服地址 将npm包的下载地址改到xxx私服。1nrm use xxx 使用nrm ls可查到我们可以使用的所有镜像源地址，* 后面是当前使用的; nrm del可删除设置的registry。 npm配置配置方式 1.通过npm的config指令；（用来管理npm的配置文件，通过config命令配置的项目实际上是通过更新配置文件npmrc来配置的） 2.通过修改npm命令的配置文件npmrc文件； 配置文件的位置： 1.用户配置文件：npm config get userconfig查看文件路径(~/.npmrc) 2.全局配置文件：npm config get globalconfig查看文件路径(/etc/npmrc) 3.内置配置文件: 安装npm的目录下的npmrc文件(/usr/local/lib/node_modules/npm/npmrc) 命令行操作1234567npm config set &lt;key&gt; &lt;value&gt; [-g|--global] //给配置参数key设置值为value；npm config get &lt;key&gt; //获取配置参数key的值；npm config delete &lt;key&gt; //删除置参数key及其值；npm config list [-l] //显示npm的所有配置参数的信息；npm config edit //编辑配置文件npm get &lt;key&gt; //获取配置参数key的值；npm set &lt;key&gt; &lt;value&gt; [-g|--global] //给配置参数key设置值为value； 配置npm registry的方式 1.通过给npm 命令添加注册源选项: npm --registry=https://registry.npm.taobao.org [npm命令] 2.通过npm的config命令配置指向国内镜像源: npm config set registry https://registry.npm.taobao.org //配置源为淘宝的源 3.在配置文件.npmrc 文件写入源地址：registry=https://registry.npm.taobao.org //写入.npmrc配置文件]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos2dx 记录]]></title>
    <url>%2F2018%2F05%2F12%2FCocos2dx-%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Creator编辑器 AnySDK多渠道打包工具 起源自Cocos2D-iPhone，创始人Ricardo Quesada。Cocos2D-X创始人王哲。 背后公司为触控科技，起步于2008年初创建的CocoaChina社区，专注于苹果产品和iOS系统开发，后推出开源2D 游戏引擎 Cocos2d。 官方的关于我们 所有分支游戏引擎均是MIT许可证下发布。 Cocos2dxX代表着Cross，即交叉。因为Cocos2D-X为开发者提供了跨平台支持，通过C++语言把游戏逻辑一次编写即可编译到iOS、Android以及更多手机平台上运行。Cocos2D-X在中国拥有70%的开发者认可和使用比例。此外，Cocos2D-X在全球199个国家地区有40万开发者使用，而Cocos2D-X已经成为全球使用率最高的手机游戏引擎之一，在中国前10名收入最高的手机游戏产品中有8款产品是由Cocos2D-X引擎及工具开发的。 现在看到的都是 v3.x 版本。3.x 和2.x相比，改动非常大。 Cocos2d-html5Cocos2d-JS的一个重要模块，是一个面向Web的游戏引擎，采用Canvas或者WebGL渲染，并完全兼容HTML5规范，所以基于Cocos2d-JS开发的游戏天然可运行在所有支持HTML5规范的浏览器 Cocos2dx-js FullVersion 全平台编译发布官网：1.1 Cocos2d-JS介绍 简单粗暴说就是用 Js 写，full version 可以js 写完后编译到全部平台：web 版翻译到 WebGl 或者 Canvas，使用的是 Cocos2dx-h5渲染；其他安卓、iOS、window等等均等于使用 js 调用底层 API, 使用的解析器是 SpiderMonkey。 JavaScript代码由Mozilla的JavaScript虚拟机SpiderMonkey进行解析和运行，同时这个虚拟机被改造为支持Cocos2d-x的类型，数据结构和对象。SpiderMonkey本身是由C/C++开发的，不仅可嵌在浏览器中，也嵌入到任何C++的程序中使用。SpiderMonkey负责脚本的解析运行，创建和检查JavaScript的数据结构，处理各种错误，提供安全检查，调试脚本的功能，并通过JSAPI实现C++代码的调用。通过这项技术，可让开发者能用纯JavaScript来开发原生游戏，游戏的开发更加高效，原型构建和验证更加便捷。 注：这种一般我都认为不靠谱，搜了下反馈确实不太靠谱。 Cocos2dx-js LiteVersion 只做 Web 如果您只关注于纯Web游戏开发，那么您还可以选择Cocos2d-JS Lite的版本，Lite版本提供Cocos2d-html5单引擎文件，可自由定制功能，并可直接嵌入到HTML页面可以开始游戏开发，提供更加简便的工作流，开发更加便捷，还兼具脚本文件体积小，性能高效等优点，具体的内容见后续的工作流章节的介绍。 Cocos CreatorCocos Creator 用户手册 cocos2d-x是游戏开发框架，Cocos Creator才称得上是完整的游戏引擎。 — 王哲 看了一小时 Cocos2dx 的文档我是拒绝的。看文档的时候就发现Cocos出过好几代编辑器， 但之前的槽点都很多。而直接下载引擎代码开发，打开一看简直毛骨悚然。但是看了下 Cocos Creator，感觉很惊艳。 Cocos Creator 官方介绍 Q: Cocos Creator 是游戏引擎吗？A: 它是一个完整的游戏开发解决方案，包括了 cocos2d-x 引擎的 JavaScript 实现（不需要学习一个新的引擎），以及能让你更快速开发游戏所需要的各种图形界面工具Q: Cocos Creator 的编辑器是什么样的？A: 完全为引擎定制打造，包含从设计、开发、预览、调试到发布的整个工作流所需的全功能一体化编辑器Q: 我不会写程序，也能使用 Cocos Creator 吗？A: 当然！Cocos Creator 编辑器提供面向设计和开发的两种工作流，提供简单顺畅的分工合作方式。Q: 我使用 Cocos Creator 能开发面向哪些平台的游戏？A: Cocos Creator 目前支持发布游戏到 Web、Android 和 iOS，以及点开即玩原生性能的 Cocos Play 手机页游平台，真正实现一次开发，全平台运行。 知乎上有人 po 出了他们公司的使用感想 可以直接在 Chrome 中进行调试，即改即见，非常顺畅。 Web平台：canvas 或者 webGL 可选 支持 VS Code 管理和编辑项目脚本代码，可以轻松实现语法高亮、智能代码提示等功能。支持配置脚本一键编译。配置代码编辑环境 搜到的各种负面反馈 cocos2dx 总在不断大改，持续学习成本高。【确实，cocos2dx 文档非常一般。但 Cocos Creator 文档非常完善。 游戏从业者认为 jsbinding 性能要求绝对不能符合要求【但我们不是做游戏哇感觉 web 就够了 2016年才发布，应该是存在了很多坑，具体可参见如何评价 Cocos2d-x 的新编辑器 Cocos Creator？ 场景开发节点 &amp; 组件Cocos Creator 的工作流程是以组件式开发为核心的，组件式架构也称作 组件-实体系统（或 Entity-Component System），简单的说，就是以组合而非继承的方式进行实体的构建。 在 Cocos Creator 中，节点（Node）是承载组件的实体，我们通过将具有各种功能的 组件（Component） 挂载到节点上，来让节点具有各式各样的表现和功能。接下来我们看看如何在场景中创建节点和添加组件。 坐标系 &amp; 变换笛卡尔坐标系 世界坐标系（World Coordinate）和本地坐标系（Local Coordinate）； 每个节点以父节点来算本地坐标系；本地坐标系会最后转成世界坐标系。 锚点（Anchor） 是节点的另一个重要属性，它决定了节点以自身约束框中的哪一个点作为整个节点的位置。我们选中节点后看到变换工具出现的位置就是节点的锚点位置。 脚本开发1234567891011121314cc.Class(&#123; extends: cc.Component, properties: &#123; &#125;, // use this for initialization onLoad: function () &#123; &#125;, // called every frame, uncomment this function to activate update callback update: function (dt) &#123; &#125;,&#125;); 生命周期onLoadstartupdatelateUpdateonDestroyonEnableonDisable 动作系统 动作系统并不能取代动画系统，动作系统提供的是面向程序员的 API 接口，而动画系统则是提供在编辑器中来设计的。同时，他们服务于不同的使用场景，动作系统比较适合来制作简单的形变和位移动画，而动画系统则强大许多，美术可以用编辑器制作支持各种属性，包含运动轨迹和缓动的复杂动画。 动作列表 网络接口脚本引用支持 ES2015 TypeScript 模块化脚本 &amp; 插件脚本 脚本加载顺序如下： Cocos2d 引擎 插件脚本（有多个的话按项目中的路径字母顺序依次加载）[可以用于配置 普通脚本（打包后只有一个文件，内部按 require 的依赖顺序依次初始化） 目标平台兼容性插件发布后将直接被目标平台加载，所以请检查插件的目标平台兼容性，否则项目发布后插件有可能不能运行。目标平台不提供原生 node.js 支持例如很多 npm 模块都直接或间接依赖于 node.js，这样的话发布到原生或网页平台后是不能用的。依赖 DOM API 的插件将无法发布到原生平台网页中可以使用大量的前端插件，例如 jQuery，不过它们有可能依赖于浏览器的 DOM API。依赖这些 API 的插件不能用于原生平台中。 子系统前几个系统应该是设计师重点要看的。 图像和渲染自带的各种组件，绘图系统、外部资源家在，还有摄像头。 UI系统多分辨率适配 动画这个动画编辑器感觉忒难用。。。 物理碰撞summary使用 Cocos Creator 做教研配套目前来看的优势 &amp; 劣势。 还需要确定的点： 是否能够插入我们自己的统计和用户代码等？如果编译到原生，是否丢失？【目前尝试 js 应该是可以的，但原生那边不知道怎么处理，此外存在兼容问题 如何放到视频上进行交互？【视频上的是否直接使用 其他js 库更好。 进一步的需求有哪些？ 优势： 工作流非常顺畅，且可以设计和程序分工合作，都可以直接看到效果。 配套文档很赞。可以考虑通过培训，建立设计师和程序都可使用的完整开发流程。 可以直接打包生成资源包上线。 花了几个小时跟着文档写了下demo，感觉上手度不错。 劣势 需要培训。设计师需要学会游戏设计，如果运营来做的话也需要一定的基础。此外脚本方面也需要学习游戏脚本开发设计，需要熟悉游戏开发术语、流程、Cocos2dx-js 的 API 等。 流程上的磨合可能会耗费一定时间和精力，这边的人基本都没有做过游戏开发。 目前发布不到两年，在持续迭代，需要踩坑。 太复杂的成本可能会比较大，例如踩到内存的坑 目前技术积累为0。 有组件库等可能会好一些。c Reference cocos 官网]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Cocos2dx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron新手入门]]></title>
    <url>%2F2018%2F02%2F11%2FElectron%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[这篇分享旨在初步介绍Electron，重点介绍其中的几个主要概念，让没有接触过Electron的开发者有一个入门的基础认知。 如果你还未接触过Electron，请看之前某乎上一篇装逼的Title：感谢 Electron，我现在有了两个身份：前端开发 和 桌面客户端开发。 基本概念是什么 官方概念：Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。 通俗理解：让你用纯 JavaScript 调用丰富的原生 APIs 创造桌面应用。使用 web 页面作为 GUI，你能把它看作一个被 JavaScript 控制的，精简版的 Chromium 浏览器。 依赖项更新（Chromium &amp; Node） Electron中Chromium的版本通常会在Chromium发行新的稳定版后的一到两周之内更新，具体时间根据升级所需的工作量而定。 为了使版本更加稳定，Electron通常会在Node.js发布了新版本的一个月之后再更新。 补充：为了保持Electron的小巧，Electron只用了Chromium的渲染库而不是其全部组件。 这使得升级Chromium更加容易，但也意味着Electron缺少了Google Chrome里的一些浏览器相关的特性。 特点 Web 技术 基于 Chromium 和 Node.js, 让你可以使用 HTML, CSS 和 JavaScript 构建应用。 跨平台 兼容 Mac, Windows 和 Linux， 它构建的应用可在这三个操作系统上面运行。 解决哪些困难 自动更新: autoUpdater 原生的菜单和通知: menu 崩溃报告: crashReporter 调试和性能分析: contentTracing … 与web项目的主要区别electron核心可以分成2个部分:主进程和渲染进程。 主进程连接着操作系统和渲染进程； 渲染进程就是我们所熟悉前端环境； 传统的web环境不能对系统进行操作，而electron相当于node环境，我们可以在项目里使用所有的node api； 目录结构抽象your-app/|── package.json|── main.js|── index.html 主进程 &amp; 渲染进程 运行 package.json 的 main 脚本的进程被称为主进程。 在主进程中运行的脚本通过创建web页面来展示用户界面。 一个 Electron 应用总是有且只有一个主进程； Electron 中的每个 web 页面运行在它自己的渲染进程中。 在普通的浏览器中，web页面通常在一个沙盒环境中运行，不被允许去接触原生的资源。 然而 Electron 的用户在 Node.js 的 API 支持下可以在页面中和操作系统进行一些底层交互。 区别 主进程使用 BrowserWindow 实例创建页面。 每个 BrowserWindow 实例都在自己的渲染进程里运行页面； 主进程管理所有的web页面和它们对应的渲染进程； 页面中调用与 GUI 相关的原生 API 是不被允许的，对应的渲染进程必须与主进程进行通讯，请求主进程进行相关的 GUI 操作； 举例1.主进程操作 12345const &#123;BrowserWindow&#125; = require('electron')// 主进程创建web页面let someWindow = new BrowserWindow(winOpts)// 加载本地的文件someWindow.loadURL('file://' + __dirname + '/index.html') 2.渲染进程操作12345678const &#123;BrowserWindow&#125; = require('electron').remoteconst modalPath = 'xxxxxx'let win = new BrowserWindow(&#123; width: 400, height: 320 &#125;)win.on('close', () =&gt; &#123; win = null &#125;)win.loadURL(modalPath)win.show() 进程间通信在web页面，不允许调用原生GUI相关的API，因为在web页面管理原生GUI资源是很危险的，会很容易泄露资源。如果你想在web页面施行GUI操作，web页面的渲染进程必须要与主进程通信，请求主进程来完成这些操作。 ipc模块（渲染进程 -&gt; 主进程）使用ipcMain和ipcRenderer模块，在渲染进程中使用ipcRender模块向主进程发送消息，主进程中ipcMain接收消息，进行操作;如果需要反馈，则通知渲染进程，渲染进程根据接收的内容执行相应的操作。 1.主进程123456const &#123;ipcMain&#125; = require('electron')ipcMain.on('close-window', (evt, data) =&gt; &#123; console.log(data) evt.sender.send('replymsg', otherData);&#125;); 2.渲染进程123456const &#123;ipcRenderer&#125; = require('electron')ipcRender.send('close-window', data);ipcRender.on('replaymsg', (evt, otherData) =&gt; &#123; console.log(otherData)&#125;) 不过切忌用 ipc 传递大量的数据，会有很大的性能问题，严重会让你整个应用卡住。 remote模块在渲染进程中使用主进程模块。为渲染进程和主进程通信提供了一种简单方法。 使用 remote 模块, 你可以调用 main 进程对象的方法, 而不必显式发送进程间消息。 12345// 渲染进程中const &#123;BrowserWindow&#125; = require('electron').remotelet win = new BrowserWindow(&#123;width: 800, height: 600&#125;)win.loadURL('https://ke.youdao.com') webContents（主进程 -&gt; 渲染进程）主进程主动向渲染进程发送消息。1this.webviewWindow.webContents.send('main-process-messages'); ipcRenderer.sendTo（渲染进程 -&gt; 渲染进程）渲染进程互相发送通信。1ipcRenderer.sendTo(windowId, 'xxx-message', 'data') 菜单（Menu &amp; MenuItem）对桌面应用来说，另一个重要的概念就是菜单栏。分为上下文菜单（右击菜单），托盘菜单（绑定到托盘图标），应用菜单（在OS X上）等多种。 1.主进程中123456789101112131415161718192021222324252627282930313233const &#123;app, Menu&#125; = require('electron') const template = [ &#123; label: 'Edit', submenu: [ &#123;role: 'undo'&#125;, &#123;role: 'redo'&#125;, &#123;type: 'separator'&#125;, &#123;role: 'cut'&#125;, &#123;role: 'copy'&#125; ] &#125;, &#123; role: 'window', submenu: [ &#123;role: 'minimize'&#125;, &#123;role: 'close'&#125; ] &#125;, &#123; role: 'help', submenu: [ &#123; label: 'Learn More', click () &#123; require('electron').shell.openExternal('https://electronjs.org') &#125; &#125; ] &#125; ] const menu = Menu.buildFromTemplate(template) Menu.setApplicationMenu(menu) 2.渲染进程中1234567const &#123;remote&#125; = require('electron')const &#123;Menu, MenuItem&#125; = remoteconst menu = new Menu()menu.append(new MenuItem(&#123;label: 'MenuItem1', click() &#123; console.log('item 1 clicked') &#125;&#125;))menu.append(new MenuItem(&#123;type: 'separator'&#125;))menu.append(new MenuItem(&#123;label: 'MenuItem2', type: 'checkbox', checked: true&#125;)) Shellshell 模块提供与桌面集成相关的功能, 使用默认应用程序管理文件和 url。 在文件管理器中显示给定的文件 将给定的文件移动到垃圾箱 播放哔哔的声音 … 12345678910// 打开系统文件目录const &#123;shell&#125; = require('electron')const os = require('os')shell.showItemInFolder(os.homedir())// 使用默认浏览器打开urlconst &#123;shell&#125; = require('electron')shell.openExternal('http://electron.atom.io') 调试渲染进程调试最广泛使用来调试指定渲染进程的工具是Chromium的开发者工具集，可以通过编程的方式在BrowserWindow的webContents中调用openDevTool()API来打开它们或者注册快捷键。123456789const &#123; BrowserWindow &#125; = require('electron')let win = new BrowserWindow()win.webContents.openDevTools()// 或者globalShortcut.register('Alt+CommandOrControl+I', () =&gt; &#123; BrowserWindow.getFocusedWindow().toggleDevTools();&#125;) 主进程调试（vscode）这里我们介绍如何利用vscode来调试Electron主进程。 步骤： 使用vscode打开electron项目 点击debug 添加配置 打开launch.json点击右下角的添加配置，添加“electron 主” 在主进程（main.js）添加断点，点击“启动”进行调试1234567891011121314&#123; // 修改launch.json文件最终为 "version": "0.2.0", "configurations": [ &#123; "type": "node", "request": "launch", "name": "Electron Main", "runtimeExecutable": "$&#123;workspaceFolder&#125;/node_modules/.bin/electron", "program": "$&#123;workspaceFolder&#125;/main.js", "protocol": "inspector" &#125; ]&#125; 注意：”protocol”: “legacy” //添加默认的协议是legacy，这个协议导致不进入断点，改为：“inspector” 打包第三方打包工具 electron-packager electron-forge electron-builder 举例（electron-packager）1234567// location of project是你项目文件夹的位置，// name of project定义你的项目名，// platform决定要构建的平台（*all* 包括Windows，Mac和Linux ），// architecture决定构建哪个构架下（x86或x64，all表示两者），// electron version让你选择要用的Electron版本electron-packager &lt;location of project&gt; &lt;name of project&gt; &lt;platform&gt; &lt;architecture&gt; &lt;electron version&gt; &lt;optional options&gt; 第一次打包用时比较久，因为要下载平台的二进制文件，随后的打包将会快的多。 与 React or Vue 集成 electron-react-boilerplate electron-vue 总结 Electron 并不是很复杂，在写完不多的主进程代码后，其他的业务代码几乎和Web应用没什么区别，甚至可以将一个线上应用迅速的包装成为一个客户端应用，比如electronic-wechat。 采坑不可避免，比如在打包、集成flash等方面等等； 基本不考虑兼容性（只需要兼容 Chromium 浏览器） 渲染进程调试和在浏览器中调试完全一致。多个web页面，每个都可以打开对应了调试工具，你可以和浏览器调试一样查看DOM、查看log、监听网络请求等等。 最后多说一句：虽然Electron 的进程间通信很方便，而且支持多窗口，但我墙裂倾向于使用 Electron 构建单窗口应用。 参考资料 官方doc 用Electron开发桌面应用 electron-quick-start electron-api-demos awesome-electron]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Electron</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebRTC初探]]></title>
    <url>%2F2017%2F11%2F09%2FWebRTC%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[WebRTC WebRTC (Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。跨平台。The WebRTC initiative is a project supported by Google, Mozilla and Opera, amongst others. This page is maintained by the Google Chrome team. 参见知乎上一个回答：https://www.zhihu.com/question/25497090/answer/43395462 自然这套API是带传输功能的。所以获取图像信源之后不应该用websocket发送图像数据，而是直接用WebRTC的通信相关API发送图像和声音（这套API是同时支持图像和声音的）数据。所以，正确的方法是什么呢？1、你得有一个实现了WebRTC相关协议的客户端。比如Chrome浏览器。2、架设一个类似MCU系统的服务器。（不知道MCU是什么？看这：MCU（视频会议系统中心控制设备））第一步，用你的客户端，比如Chrome浏览器，通过WebRTC相关的媒体API获取图像及声音信源，再用WebRTC中的通信API将图像和声音数据发送到MCU服务器。第二步，MCU服务器根据你的需求对图像和声音数据进行必要的处理，比如压缩、混音等。第三步，需要看直播的用户，通过他们的Chrome浏览器，链接上你的MCU服务器，并收取服务器转发来的图像和声音流。 peer to peer “Peer”在英语里有“对等者”和“伙伴”的意义。因此，从字面上，P2P可以理解为对等互联网。国内的媒体一般将P2P翻译成“点对点”或者“端对端”，学术界则统一称为对等计算。P2P可以定义为：网络的参与者共享他们所拥有的一部分硬件资源（处理能力、存储能力、网络连接能力、打印机等），这些共享资源通过网络提供服务和内容，能被其它对等节点(Peer)直接访问而无需经过中间实体。在此网络中的参与者既是资源（服务和内容）提供者（Server），又是资源获取者（Client）。—- protocols 协议 ICE (Interactive Connectivity Establishment)互动式连接建立是由IETF的MMUSIC工作组开发出来的一种framework，可整合各种NAT穿透技术，如STUN、TURN（Traversal Using Relay NAT，中继NAT实现的穿透）、RSIP（Realm Specific IP，特定域IP）等。该framework可以让SIP的客户端利用各种NAT穿透方式打穿远程的防火墙。 NAT (Network Address Translation)在计算机网络中，网络地址转换（Network Address Translation，缩写为NAT），也叫做网络掩蔽或者IP掩蔽（IP masquerading），是一种在IP数据包通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。这种技术普遍使用在有多台主机但只通过一个公有IP地址访问因特网的私有网络中。 STUN（Session Traversal Utilities for NAT）NAT会话穿越应用程序是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间创建UDP通信。该协议由RFC 5389定义。 TURN（Traversal Using Relay NAT）TURN是一个client-server协议。TURN的NAT穿透方法与STUN类似，都是通过取得应用层中的公有地址达到NAT穿透。但实现TURN client的终端必须在通讯开始前与TURN server进行交互，并要求TURN server产生”relay port”，也就是relayed-transport-address。这时TURN server会建立peer，即远端端点（remote endpoints），开始进行中继（relay）的动作，TURN client利用relay port将资料传送至peer，再由peer转传到另一方的TURN client。 SDP (Session Description Protocol)会话描述协议（Session Description Protocol或简写SDP）描述的是流媒体的初始化参数。此协议由IETF发表为 RFC 2327。 API由于兼容性问题，请现加载 adapter https://github.com/webrtc/adapter/ getUserMedia()https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getUserMedia 1navigator.getUserMedia(constraints, successCallback, errorCallback); constranits 一个包含了video 和 audio两个成员的MediaStreamConstraints 对象，用于说明请求的媒体类型。 回调拿到的是一个 stream 对象，参见MediaStream Interface MediaRecorder()RTCPeerConnectionmethod: RTCPeerConnection(): RTCPeerConnection的初始化函数 createOffer(): 生成一个offer，它是一个带有特定的配置信息寻找远端匹配机器（peer）的请求 123456pc1.createOffer( offerOptions).then( onCreateOfferSuccess, onCreateSessionDescriptionError) createAnswer():在协调一条连接中的两端offer/answers时，根据从远端发来的offer生成一个answer。 setLocalDescription(): 改变与连接相关的本地描述。 setRemoteDescription(): 改变与连接相关的远端描述。 createDataChannel(): 在一条连接上建立一个新的RTCDataChannel（用于数据发送）。这个方法把一个数据对象作为参数，数据对象中包含必要的配置信息。 dataConstraint: https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createDataChannel 传输基于 SCTP WebRTC的通讯终端需要获取和交换本地及远程的视频音频信息，例如分辨率等；这一类 metadata 数据在onCreateAnswerSuccess等方法接收到的参数中以 SDP 的格式传送。 event: onicecandidate: 当一个 RTCICECandidate 对象被添加时，这个事件被触发。 oniceconnectionstatechange: 当iceConnectionState 改变时，这个事件被触发。 onaddstream: 当MediaStream 被远端机器添加到这条连接时，该事件会被触发。 how to establish a p2p connection 每个端创建一个RTCPeerConnection, 添加从getUserMedia()获取到的 stream 获取网络信息，找到潜在的连接点，也就是ICE candidates. 获取和分享本地及远程描述, metadata about local media in SDP format. demo 中没有 server, 实际参考 WebRTC in the real world: STUN, TURN and signaling Reference https://webrtc.org/ https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API Peer to Peer 综述 http://www.intsci.ac.cn/users/luojw/P2P/index.html]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>webrtc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端视频autoplay+playsinline小结]]></title>
    <url>%2F2017%2F09%2F06%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%A7%86%E9%A2%91autoplay-playsinline%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在移动端开发中我们会遇到音视频相关的功能需求，而针对不同系统、不同厂商的移动设备、不同浏览器环境，音视频在移动端的表现存在不少差异，这些差异体现在UI、交互、默认属性表现等方面。这里我针对移动端的video元素在自动播放和内联播放两方面进行相关实验，比较不同环境的差异并作出记录，以备后用。 自动播放仅设置autoPlay1&lt;video width="320" height="240" controls src="http://www.w3school.com.cn/i/movie.mp4" autoplay="autoplay"&gt;&lt;/video&gt; 原生 微信 微博 QQ UC 搜狗 360 360极速 IOS N N N N N N N N Android Y N N Y N N Y N 设置autoPlay + muted1&lt;video width="320" height="240" controls src="http://www.w3school.com.cn/i/movie.mp4" autoplay="autoplay" muted&gt;&lt;/video&gt; 原生 微信 微博 QQ UC 搜狗 360 360极速 IOS N N N N N N N N Android Y N 不定 Y N N Y N video.play()主动触发12345&lt;video width="320" height="240" controls src="http://www.w3school.com.cn/i/movie.mp4" id="v1"&gt;&lt;/video&gt; setTimeout(() =&gt; &#123; document.getElementById('v1').play() &#125;, 1000); 原生 微信 微博 QQ UC 搜狗 360 360极速 IOS N N N Y N N N N Android Y N N Y N N Y N WeixinJSBridgeReady事件触发play()123456789&lt;video width="320" height="240" controls src="http://www.w3school.com.cn/i/movie.mp4" id="v1"&gt;&lt;/video&gt; document.addEventListener( 'WeixinJSBridgeReady', function() &#123; document.getElementById('v1').play() &#125;, false ) IOS微信支持，Android微信不支持 取消全屏播放设置playsinline1&lt;video width="320" height="240" controls src="http://www.w3school.com.cn/i/movie.mp4" webkit-playsinline="true" playsinline="true"&gt;&lt;/video&gt; 原生 微信 微博 QQ UC 搜狗 360 360极速 IOS Y Y N Y N Y 诡异 Y Android Y Y Y Y Y Y Y Y ios微博取消全屏，可以用 https://www.npmjs.com/package/iphone-inline-video]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React+Mobx+videojs重构web直播系统]]></title>
    <url>%2F2017%2F08%2F01%2F%E5%9F%BA%E4%BA%8Evideojs%E7%9A%84web%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F%E9%87%8D%E6%9E%84%2F</url>
    <content type="text"><![CDATA[在正式入职之后接手的第一个重点项目便是web直播系统的重构。因为在实习期间一直参与旧版直播系统的迭代开发，同时因旧版本技术栈相对陈旧、代码维护成本过高、扩展能力较弱等原因，决定于2018年进行彻底重构，针对UI做出重新设计。整体系统比较简单，主体由视频和讨论区两大元素构成，在技术选型上采用React作为UI层框架，Mobx作为状态管理库，videoJs作为视频播放器类库。本文针对重构过程中涉及的主要技术点进行记录，留作今后查缺补漏。 技术选型 Mobx 无论是Redux / MobX ，均是开源的状态管理库，用状态描述 UI 界面，与 React 都不具有强绑定关系 store Mobx-react 绑定库 主要提供API：Provider &amp; inject &amp; observer redux react-redux mobx mobx-react 装饰器 @表示装饰器，可以在 ES7 或者 TypeScript 类属性中使用。Mobx中装饰器的使用并非必须，只是语法稍有区别。 Babel默认情况下是不支持装饰器的，需配置相应plugin: !!注意， plugins 属性中: transform-decorators-legacy 应放在最前面。当使用 react native 时，可用下面的预设来代替 transform-decorators-legacy: H5的video标签基本使用H5中的video标签可以进行视频播放，写一个video设置一个src属性指定媒体源地址就可以实现媒体播放了。针对低版本浏览器video的HTML结构也提供了友好的兼容方案，只需要在video标签内写上不兼容时要展示的HTML内容即可。 video的属性 src: 视频地址controls: 控制条； poster: 视频下载时显示的图像； preload: 预加载； playsinline: 防止ios用户视频播放自动全屏。 x-webkit-airplay=“allow” : 支持ios的AirPlay功能； x5-video-orientation: 声明播放器支持的方向； x5­-video­-player­-fullscreen:全屏设置； 媒体格式目前原生H5支持的媒体格式主要有MP4、OGG、WebM、M3U8等，但各大浏览器厂商之间对媒体格式的支持各不相同： canPlayType API可以通过HTMLVideoElement的canPlayType API进行当前环境的格式兼容判断: ‘probably’: The specified media type appears to be playable. ‘maybe’: Cannot tell if the media type is playable without playing it. ‘ ‘ :The specified media type definitely cannot be played. 环境差异 UI不一致 API实现与支持程度不一致（标准API里的controls、poster、autoplay…未必有效） 事件交互行为不一致（播放进度变化、事件触发频率不同、部分事件触发时相应状态值未必可靠、部分场景缺少事件..） 媒体格式的支持无法保证 Video.js简介Video.js 是一个通用的在网页中嵌入视频播放器的 JS 库，自动检测浏览器对 HTML5 的支持情况，如果不支持则自动使用 Flash 播放器。（目前版本：v6.5.0） 优点： 开源免费（https://github.com/videojs/video.js）。 2.接入简单（几分钟即可完成基础配置，搭建视频页面）。 3.几乎兼容所有主流浏览器，并优先使用html5；在不支持的浏览器中，会自动使用flash进行播放。 界面可定制、插件可扩展。 注意： v6.0.0版本之前：默认将flash build在sdk中; v6.0.0版本之后：需手动引入官方提供的flash tech（https://github.com/videojs/videojs-flash）; Skins &amp; Icons &amp; Plugins Skinning 播放器样式完全通过html+css构建，可以通过覆盖基础css样式进行调整； Icons 除此之外，videoJS本身固有的几个class如果灵活运用，可以减少部分细节处理工作量 vjs-live-control // 展示直播状态 vjs-poster // 展示默认图 vjs-seeking // 展示加载中loading vjs-controls-enabled // 展示控制条 vjs-controls-disabled //隐藏所有的控制组件 vjs-ended // 播放结束样式 vjs-error // 视频异常展示错误信息 … Plugins Video.js 本身很简单，支持基础的播放功能和特性。任何复杂或高级特性将以插件形式提供，比如：播放列表、分析、广告和支持先进的格式如HLS等。(http://videojs.com/plugins/) Video.js 提供强大而丰富的插件同时，你也可以自己创建插件并发布。 1.插件方法中的this指向所创建plugin依附的videojs实例； 2.插件方法中可以使用任何videojs API进行相关处理； 3.例如在直播系统中：有关视频的日志上报、各种播放器事件监听处理等，均可放到单独的插件中，方便组织代码； Step 1: Write Some Javascript Step 2: Registering A Plugin Step 3: Using A Plugin 初始化 方式一： 方式二：（推荐） 配置参数一般，对于播放器的初始化，除了传入必备的视频源地址以及视频格式之外，videoJS支持配置额外的options。如： 直播type：’rtmp/flv’ 录播type：’video/mp4’ 常用API 常用事件 主要事件的处理 loadstart：标识播放器开始加载视频，在这里可以展示加载中状态、设置定时器判定首次加载是否成功; error：标识播放器异常，一般原因有网络异常、视频解码异常等，此时进行主动拉流操作，并在多次尝试拉流失败后给出用户提示； canplaythrough、 play、playing、 seeked：都可能标识视频已正常播放，此时应对错误提示、加载中提示、切换线路提示等UI进行隐藏调整； waiting：标识视频发生卡顿较为准确的事件，可以在此处进行视频卡顿次数的记录并展示卡顿提示等信息； pause：标识视频暂停，可以做一些UI（如：预览、控制条等）方面的显隐操作; timeupdate：标识视频进行中位置发生改变，可在此完成协同播放时间的其他界面操作; ended：标识视频播放结束，可做一系列资源回收、清理工作，或者结束提示、循环播放等操作； stalled：标识视频资源不可用，这时应进行主动拉流或者提示用户切换线路等操作（但要注意：在部分浏览器中，视频长时间处于暂停状态后可能也会触发此事件，这是应该忽略）； 其他视频播放监控 视频异常播放器提供的error事件回调基本涵盖了绝大多数异常情况，包括视频格式无法解析、视频源错误、网络异常、拉流超时等； 视频首次加载过程当音频/视频处于首次加载过程中时，大致会发生以下事件： 1.play、playing、canplaythrough三个事件不一定都会触发，顺序也并不固定； 2.不同浏览器中（如Edge）可能直接触发到seeked事件即加载完成开始播放，并不会有play、playing、canplaythrough这些； durationchange有时候会在loadstart事件之前触发； 视频首次加载&amp;卡顿 这里的关键在于定时器到期后判断视频是否处于正常状态 在web直播系统中,我们针对视频首次加载是否成功，视频播放中产生的卡顿进行监测记录： 1.首次加载：从loadstart事件开始若干秒内视频是否加载成功； 2.卡顿：从waiting事件触发后若干秒内是否恢复正常播放； 其他问题小结 Video.networkState() 判断网络状态 0 = NETWORK_EMPTY - 音频/视频尚未初始化 1 = NETWORK_IDLE - 音频/视频是活动的且已选取资源，但并未使用网络 2 = NETWORK_LOADING - 浏览器正在下载数据 3 = NETWORK_NO_SOURCE - 未找到音频/视频来源 在开发中遇到这种情况：直播时，如果web端直接断开网络连接，视频播放器是不会抛出任何异常事件的，这时如果我们想为用户提供主动拉流，需要监测网络状态变化。Video.networkState经试验并不可取，无论网络异常与否，都会从0或2最终变化到1。（最后通过监听offline &amp; online事件获取网络状态变化） video.addTextTrack() addTextTrack方法创建和返回新的文本轨道。 新的TextTrack对象会被添加到视频/音频元素的文本轨道列表中。 浏览器支持程度：所有主流浏览器都不支持addTextTrack方法。 IE浏览器，每次暂停再开始或快进/退视频，视频倍速会被自动重置为1倍速]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>React</tag>
        <tag>直播</tag>
        <tag>Mobx</tag>
        <tag>VideoJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitPage+Hexo建站]]></title>
    <url>%2F2017%2F04%2F01%2FGitPage-Hexo%E5%BB%BA%E7%AB%99%2F</url>
    <content type="text"><![CDATA[这里简要记录 GitPage + Hexo 快速建立个人站点的过程。建站方式很多，依托的平台不尽相同，我选择GitPage+Hexo，其具有操作简单、维护成本低、文档详细等优势。网上已经有很多此类教程，此文并无过多创新，仅在记录自己建站中的操作步骤、相关参考文档等，力求简明扼要。 环境 mac os 10.11.6 node v8.14.0 yarn v1.13.0 git v2.10.1 hexo v3.8.0 next v7.0.1 GitHub创建Pages项目创建一个名称为{yourusername}.github.io的新仓库即可。其中的 yourusername 填写自己的用户名，Github会识别并自动将该仓库设为Github Pages。用户主页是唯一的，填其他名称只会被当成普通项目。 分支管理Github Pages部署分支设置中，一般分为： master 分支 gh-pages 分支（需要手动创建） 我的做法： blog-src 分支用于存放源码 master 分支用于部署 Hexo安装1$ yarn global add hexo-cli 创建hexo项目1$ hexo init [projectname] 拉取Github项目到本地1$ git clone https://github.com/yourusername/yourprojectname.git 把之前生成的hexo项目文件夹下的内容全部复制过来。 常用命令 hexo init [folder]: 新建项目 hexo new [post_title]: 新建文章 hexo generate [-d]: 生成静态文件 hexo serve [-p port]: 启动本地服务器。默认访问网址为： http://localhost:4000/ hexo deploy [-g]: 部署 hexo clean: 清除缓存 具体参考：hexo命令 更文步骤启本地服务 - 新建&amp;编写文章 - 生成静态文件 - 部署 具体参考：hexo写作 配置_config.yml主要是针对网站的基本信息配置，比如网站(副)标题、描述等。 具体参考：hexo配置 更换主题这里我采用hexo的next主题，另外还有非常多主题可供选择，详见hexo-themes 具体参考： theme-next 下载1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 修改项目配置根目录下的_config.yml中，theme：next 修改主题配置这里罗列出我进行的主要个性化配置:（themes/next下的_config.yml） favicon footer menu scheme avatar auto_excerpt sidebar back2top social third party services 具体参考：theme-next doc 备注 github添加公钥 如果是首次在一台机器进行部署（或更换了环境），记得在github添加公钥。具体参考：使用Github SSH Key以免去Hexo部署时输入密码]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>GitPage</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
